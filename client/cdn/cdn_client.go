// Code generated by go-swagger; DO NOT EDIT.

package cdn

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new cdn API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for cdn API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
ConnectScopeToOrigin connects scope to origin will connect a scope with an origin creating the origin if necessary when the request contains a priority which an origin already associated with the scope has set the existing origin will be disconnected the priority of an origin already associated with a scope can be modified via this endpoint
*/
func (a *Client) ConnectScopeToOrigin(params *ConnectScopeToOriginParams, authInfo runtime.ClientAuthInfoWriter) (*ConnectScopeToOriginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConnectScopeToOriginParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ConnectScopeToOrigin",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/origins",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ConnectScopeToOriginReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ConnectScopeToOriginOK), nil

}

/*
ConnectSiteToCertificate connects site to certificate will associate a site with a certificate without validating if the site has a hostname covered by the certificate this is useful for preparation work required for getting a site ready for traffic if a certificate is uploaded which contains hostnames for sites it will automatically be connected to those sites if a hostname is added to a site which is covered by an s s l certificate it will automatically be connected to the certificate
*/
func (a *Client) ConnectSiteToCertificate(params *ConnectSiteToCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*ConnectSiteToCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConnectSiteToCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ConnectSiteToCertificate",
		Method:             "PUT",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/certificates/{certificate_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ConnectSiteToCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ConnectSiteToCertificateOK), nil

}

/*
CreateCertificate creates certificate creates a certificate in the stack the certificate will automatically be associated with scope hostnames which are contained in either the subject or the alternative names in the certificate
*/
func (a *Client) CreateCertificate(params *CreateCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*CreateCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateCertificate",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateCertificateOK), nil

}

/*
CreateScope creates scope creates a new configuration scope
*/
func (a *Client) CreateScope(params *CreateScopeParams, authInfo runtime.ClientAuthInfoWriter) (*CreateScopeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateScopeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateScope",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateScopeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateScopeOK), nil

}

/*
CreateScopeHostname creates scope hostname creates a hostname on a scope
*/
func (a *Client) CreateScopeHostname(params *CreateScopeHostnameParams, authInfo runtime.ClientAuthInfoWriter) (*CreateScopeHostnameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateScopeHostnameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateScopeHostname",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/hostnames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateScopeHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateScopeHostnameOK), nil

}

/*
CreateScopeRule creates scope rule creates a new rule in a scope
*/
func (a *Client) CreateScopeRule(params *CreateScopeRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateScopeRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateScopeRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateScopeRule",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateScopeRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateScopeRuleOK), nil

}

/*
CreateSite creates site will create a site
*/
func (a *Client) CreateSite(params *CreateSiteParams, authInfo runtime.ClientAuthInfoWriter) (*CreateSiteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSiteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSite",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateSiteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSiteOK), nil

}

/*
CreateSiteScript creates site script creates an edge script for a site
*/
func (a *Client) CreateSiteScript(params *CreateSiteScriptParams, authInfo runtime.ClientAuthInfoWriter) (*CreateSiteScriptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateSiteScriptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "CreateSiteScript",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scripts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateSiteScriptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateSiteScriptOK), nil

}

/*
DeleteCertificate deletes certificate deletes a certificate from the stack
*/
func (a *Client) DeleteCertificate(params *DeleteCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteCertificateNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteCertificate",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates/{certificate_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteCertificateNoContent), nil

}

/*
DeleteScope deletes scope deletes a scope
*/
func (a *Client) DeleteScope(params *DeleteScopeParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteScopeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteScopeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteScope",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteScopeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteScopeNoContent), nil

}

/*
DeleteScopeHostname deletes scope hostname deletes a hostname from a scope
*/
func (a *Client) DeleteScopeHostname(params *DeleteScopeHostnameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteScopeHostnameNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteScopeHostnameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteScopeHostname",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/hostnames/{domain}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteScopeHostnameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteScopeHostnameNoContent), nil

}

/*
DeleteScopeRule deletes scope rule deletes a scope rule
*/
func (a *Client) DeleteScopeRule(params *DeleteScopeRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteScopeRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteScopeRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteScopeRule",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/rules/{rule_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteScopeRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteScopeRuleNoContent), nil

}

/*
DeleteSite deletes site will delete a site
*/
func (a *Client) DeleteSite(params *DeleteSiteParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSiteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSiteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSite",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteSiteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSiteNoContent), nil

}

/*
DeleteSiteScript deletes site script delete an edge script for a site
*/
func (a *Client) DeleteSiteScript(params *DeleteSiteScriptParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteSiteScriptNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteSiteScriptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DeleteSiteScript",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scripts/{script_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteSiteScriptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteSiteScriptNoContent), nil

}

/*
DisableSite disables site disables site delivery can be reversed via a call to enable
*/
func (a *Client) DisableSite(params *DisableSiteParams, authInfo runtime.ClientAuthInfoWriter) (*DisableSiteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisableSiteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DisableSite",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/disable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DisableSiteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DisableSiteNoContent), nil

}

/*
DisconnectScopeFromOrigin disconnects scope from origin will disconnect a scope from an origin
*/
func (a *Client) DisconnectScopeFromOrigin(params *DisconnectScopeFromOriginParams, authInfo runtime.ClientAuthInfoWriter) (*DisconnectScopeFromOriginNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisconnectScopeFromOriginParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "DisconnectScopeFromOrigin",
		Method:             "DELETE",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/origins/{origin_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DisconnectScopeFromOriginReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DisconnectScopeFromOriginNoContent), nil

}

/*
EnableSite enables site re enables delivery on a site
*/
func (a *Client) EnableSite(params *EnableSiteParams, authInfo runtime.ClientAuthInfoWriter) (*EnableSiteNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableSiteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "EnableSite",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/enable",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &EnableSiteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*EnableSiteNoContent), nil

}

/*
GetCertificate gets certificate returns a certificate
*/
func (a *Client) GetCertificate(params *GetCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*GetCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCertificate",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates/{certificate_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCertificateOK), nil

}

/*
GetCertificateSites gets certificate sites returns the sites which are implicitly associated with a certificate
*/
func (a *Client) GetCertificateSites(params *GetCertificateSitesParams, authInfo runtime.ClientAuthInfoWriter) (*GetCertificateSitesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertificateSitesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCertificateSites",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates/{certificate_id}/sites",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCertificateSitesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCertificateSitesOK), nil

}

/*
GetCertificateVerificationDetails gets certificate verification details will return whether the requested certificate requires manual verification and the details necessary for providing that verification
*/
func (a *Client) GetCertificateVerificationDetails(params *GetCertificateVerificationDetailsParams, authInfo runtime.ClientAuthInfoWriter) (*GetCertificateVerificationDetailsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertificateVerificationDetailsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCertificateVerificationDetails",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates/{certificate_id}/verification_details",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCertificateVerificationDetailsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCertificateVerificationDetailsOK), nil

}

/*
GetCertificates gets certificates returns certificates in the stack
*/
func (a *Client) GetCertificates(params *GetCertificatesParams, authInfo runtime.ClientAuthInfoWriter) (*GetCertificatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCertificatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetCertificates",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetCertificatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCertificatesOK), nil

}

/*
GetClosestPop gets pops returns the list of available pops

Performs a scan and returns the Pop with the fastest response.
*/
func (a *Client) GetClosestPop(params *GetClosestPopParams, authInfo runtime.ClientAuthInfoWriter) (*GetClosestPopOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClosestPopParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetClosestPop",
		Method:             "GET",
		PathPattern:        "/cdn/v1/pops/closest",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClosestPopReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClosestPopOK), nil

}

/*
GetMetrics gets metrics returns metrics for sites in the stack
*/
func (a *Client) GetMetrics(params *GetMetricsParams, authInfo runtime.ClientAuthInfoWriter) (*GetMetricsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMetricsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetMetrics",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/metrics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetMetricsOK), nil

}

/*
GetOrigin gets origin returns an origin
*/
func (a *Client) GetOrigin(params *GetOriginParams, authInfo runtime.ClientAuthInfoWriter) (*GetOriginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOriginParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetOrigin",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/origins/{origin_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOriginReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOriginOK), nil

}

/*
GetOrigins gets origins returns the origins in the stack
*/
func (a *Client) GetOrigins(params *GetOriginsParams, authInfo runtime.ClientAuthInfoWriter) (*GetOriginsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOriginsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetOrigins",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/origins",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOriginsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOriginsOK), nil

}

/*
GetPops gets pops returns the list of available pops
*/
func (a *Client) GetPops(params *GetPopsParams, authInfo runtime.ClientAuthInfoWriter) (*GetPopsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPopsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPops",
		Method:             "GET",
		PathPattern:        "/cdn/v1/pops",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPopsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPopsOK), nil

}

/*
GetPurgeStatus gets purge status returns the status of a purge request
*/
func (a *Client) GetPurgeStatus(params *GetPurgeStatusParams, authInfo runtime.ClientAuthInfoWriter) (*GetPurgeStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPurgeStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetPurgeStatus",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/purge/{purge_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetPurgeStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPurgeStatusOK), nil

}

/*
GetScopeConfiguration gets scope configuration returns the configuration for a scope
*/
func (a *Client) GetScopeConfiguration(params *GetScopeConfigurationParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopeConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopeConfigurationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopeConfiguration",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/configuration",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopeConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopeConfigurationOK), nil

}

/*
GetScopeHostnames gets scope hostnames returns the hostnames configured for a scope these hostnames allow the c d n to recognize an HTTP request and associate it with a site
*/
func (a *Client) GetScopeHostnames(params *GetScopeHostnamesParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopeHostnamesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopeHostnamesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopeHostnames",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/hostnames",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopeHostnamesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopeHostnamesOK), nil

}

/*
GetScopeOrigins gets scope origins returns the origins associated with a scope
*/
func (a *Client) GetScopeOrigins(params *GetScopeOriginsParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopeOriginsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopeOriginsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopeOrigins",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/origins",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopeOriginsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopeOriginsOK), nil

}

/*
GetScopeRule gets scope rule returns a rule in a scope
*/
func (a *Client) GetScopeRule(params *GetScopeRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopeRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopeRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopeRule",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/rules/{rule_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopeRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopeRuleOK), nil

}

/*
GetScopeRuleConfiguration gets scope rule configuration returns the configuration for a scope rule
*/
func (a *Client) GetScopeRuleConfiguration(params *GetScopeRuleConfigurationParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopeRuleConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopeRuleConfigurationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopeRuleConfiguration",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/rules/{rule_id}/configuration",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopeRuleConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopeRuleConfigurationOK), nil

}

/*
GetScopeRules gets scope rules returns the rules for a scope
*/
func (a *Client) GetScopeRules(params *GetScopeRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetScopeRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScopeRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetScopeRules",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetScopeRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScopeRulesOK), nil

}

/*
GetSite gets site returns a site
*/
func (a *Client) GetSite(params *GetSiteParams, authInfo runtime.ClientAuthInfoWriter) (*GetSiteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSite",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteOK), nil

}

/*
GetSiteCertificates gets site certificates returns certificates which are implicity associated with a site
*/
func (a *Client) GetSiteCertificates(params *GetSiteCertificatesParams, authInfo runtime.ClientAuthInfoWriter) (*GetSiteCertificatesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteCertificatesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSiteCertificates",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/certificates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteCertificatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteCertificatesOK), nil

}

/*
GetSiteDNSTargets gets site Dns targets returns a set of DNS addresses that can be used for requests to the site
*/
func (a *Client) GetSiteDNSTargets(params *GetSiteDNSTargetsParams, authInfo runtime.ClientAuthInfoWriter) (*GetSiteDNSTargetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteDNSTargetsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSiteDnsTargets",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/dns/targets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteDNSTargetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteDNSTargetsOK), nil

}

/*
GetSiteScopes gets site scopes returns the scopes for a site
*/
func (a *Client) GetSiteScopes(params *GetSiteScopesParams, authInfo runtime.ClientAuthInfoWriter) (*GetSiteScopesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteScopesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSiteScopes",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteScopesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteScopesOK), nil

}

/*
GetSiteScript gets site script gets a single script for a site
*/
func (a *Client) GetSiteScript(params *GetSiteScriptParams, authInfo runtime.ClientAuthInfoWriter) (*GetSiteScriptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteScriptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSiteScript",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scripts/{script_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteScriptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteScriptOK), nil

}

/*
GetSiteScript2 gets site script gets a single script for a site
*/
func (a *Client) GetSiteScript2(params *GetSiteScript2Params, authInfo runtime.ClientAuthInfoWriter) (*GetSiteScript2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteScript2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSiteScript2",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scripts/{script_id}/{script_version}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteScript2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteScript2OK), nil

}

/*
GetSiteScripts gets site scripts gets a paginated list of scripts for a site
*/
func (a *Client) GetSiteScripts(params *GetSiteScriptsParams, authInfo runtime.ClientAuthInfoWriter) (*GetSiteScriptsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSiteScriptsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSiteScripts",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scripts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSiteScriptsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSiteScriptsOK), nil

}

/*
GetSites gets sites returns sites in the stack
*/
func (a *Client) GetSites(params *GetSitesParams, authInfo runtime.ClientAuthInfoWriter) (*GetSitesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetSitesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "GetSites",
		Method:             "GET",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetSitesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetSitesOK), nil

}

/*
PurgeContent purges content purges content from the c d n a purge ID is returned which can be used in calls to get the purge status at cdn v1 stacks stack id purge purge id
*/
func (a *Client) PurgeContent(params *PurgeContentParams, authInfo runtime.ClientAuthInfoWriter) (*PurgeContentOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPurgeContentParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "PurgeContent",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/purge",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PurgeContentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PurgeContentOK), nil

}

/*
RenewCertificate renews certificate will start a certificate renewal process
*/
func (a *Client) RenewCertificate(params *RenewCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*RenewCertificateNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRenewCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "RenewCertificate",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates/{certificate_id}/renew",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RenewCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RenewCertificateNoContent), nil

}

/*
RequestCertificate requests certificate creates a new certificate for a site the optional list of hosts should be delivery domains for the site if no hosts parameter is provided all delivery domains for a site will be included in the s a n field if the hosts parameter is provided the first entry in the list will be used as the certificate common name
*/
func (a *Client) RequestCertificate(params *RequestCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*RequestCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRequestCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "RequestCertificate",
		Method:             "POST",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/certificates/request",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RequestCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RequestCertificateOK), nil

}

/*
ScanOrigin scans origin returns information regarding an origin such as its IP address and whether or not it supports s s l
*/
func (a *Client) ScanOrigin(params *ScanOriginParams, authInfo runtime.ClientAuthInfoWriter) (*ScanOriginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewScanOriginParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ScanOrigin",
		Method:             "POST",
		PathPattern:        "/cdn/v1/origins/scan",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ScanOriginReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ScanOriginOK), nil

}

/*
UpdateCertificate updates certificate updates a certificate this can be used for providing updated certificate or key information
*/
func (a *Client) UpdateCertificate(params *UpdateCertificateParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateCertificateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateCertificateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateCertificate",
		Method:             "PUT",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/certificates/{certificate_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateCertificateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateCertificateOK), nil

}

/*
UpdateOrigin updates origin updates an origin allowing for changes to paths hostnames and ports
*/
func (a *Client) UpdateOrigin(params *UpdateOriginParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateOriginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateOriginParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateOrigin",
		Method:             "PATCH",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/origins/{origin_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateOriginReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateOriginOK), nil

}

/*
UpdateScopeConfiguration updates scope configuration updates the configuration for a scope
*/
func (a *Client) UpdateScopeConfiguration(params *UpdateScopeConfigurationParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateScopeConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateScopeConfigurationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateScopeConfiguration",
		Method:             "PATCH",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/configuration",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateScopeConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateScopeConfigurationOK), nil

}

/*
UpdateScopeRuleConfiguration updates scope rule configuration updates the configuration for a scope rule
*/
func (a *Client) UpdateScopeRuleConfiguration(params *UpdateScopeRuleConfigurationParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateScopeRuleConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateScopeRuleConfigurationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateScopeRuleConfiguration",
		Method:             "PATCH",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scopes/{scope_id}/rules/{rule_id}/configuration",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateScopeRuleConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateScopeRuleConfigurationOK), nil

}

/*
UpdateSiteScript updates site script updates the code or paths of a script if the code is changed a new version will be created
*/
func (a *Client) UpdateSiteScript(params *UpdateSiteScriptParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateSiteScriptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateSiteScriptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "UpdateSiteScript",
		Method:             "PATCH",
		PathPattern:        "/cdn/v1/stacks/{stack_id}/sites/{site_id}/scripts/{script_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateSiteScriptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateSiteScriptOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}

// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/swag"
)

// CustconfCompression The compression policy allows you to provide a list of file extensions you want the CDN caching servers to automatically compress before delivering content to end users. This policy is typically used when your origin server does not support compression or you are unable to configure your origin to compress your files. If your origin is configured to already compress files, you should consider adding the Compressed Origin Pull policy to your host, which will enable the CDN caching server to request compressed (gzip) version of your assets. The compressed origin pull policy can be found in the Origin Pull policies list. Please note that our caching servers schedule the compression of files, and typically you do not see the compressed delivery until the file has been requested several times. Typically, this list is comprised of text files like javascript, html and CSS files. You should not include file extensions that match media files (images, videos, or audio files) or any other file format that includes a built in compression algorithm. Attempting to further compress these types of files usually results in a larger file being delivered to end users.
// swagger:model custconfCompression
type CustconfCompression struct {

	// enabled
	Enabled bool `json:"enabled"`

	// String of values delimited by a ',' character. The list of file extensions you want the caching servers to use to identify the content you want compressed before delivering it to end users
	Gzip string `json:"gzip,omitempty"`

	// This is used by the API to perform conflict checking
	ID string `json:"id,omitempty"`

	// level
	Level string `json:"level,omitempty"`

	// String of values delimited by a ',' character. A list of rules based on MIME types you want the caching servers to use to identify content you want compressed before delivering it to end users.
	Mime string `json:"mime,omitempty"`
}

// Validate validates this custconf compression
func (m *CustconfCompression) Validate(formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CustconfCompression) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustconfCompression) UnmarshalBinary(b []byte) error {
	var res CustconfCompression
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

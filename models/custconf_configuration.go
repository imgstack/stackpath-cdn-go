// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// CustconfConfiguration custconf configuration
// swagger:model custconfConfiguration
type CustconfConfiguration struct {

	// access log Ip obfuscation
	AccessLogIPObfuscation *CustconfAccessLogIPObfuscation `json:"accessLogIpObfuscation,omitempty"`

	// access logger
	AccessLogger *CustconfAccessLogger `json:"accessLogger,omitempty"`

	// access logs
	AccessLogs *CustconfAccessLogs `json:"accessLogs,omitempty"`

	// access logs config
	AccessLogsConfig *CustconfAccessLogsConfig `json:"accessLogsConfig,omitempty"`

	// account
	Account *CustconfAccount `json:"account,omitempty"`

	// IP address restrictions allow you to configure your CDN container to grant
	// or deny a specific IP addresses or range of IP addresses from accessing
	// content cached in a directory in your CDN container.
	AuthACL []*CustconfAuthACL `json:"authACL,omitempty"`

	// Geographic restrictions allow you to restrict content to end users in
	// specific locations.  The IP address of incoming requests is checked against
	// a current list of IP allocations to countries and to states within the US.
	// If an end user’s IP address is not found in the list, they are allowed
	// access to the content by default. The feature has both an Include and an
	// Exclude list which are used to target the allowed audience.
	AuthGeo []*CustconfAuthGeo `json:"authGeo,omitempty"`

	// auth Http basic
	AuthHTTPBasic *CustconfAuthHTTPBasic `json:"authHttpBasic,omitempty"`

	// auth referer
	AuthReferer *CustconfAuthReferer `json:"authReferer,omitempty"`

	// auth sign urls in playlist
	AuthSignUrlsInPlaylist *CustconfAuthSignUrlsInPlaylist `json:"authSignUrlsInPlaylist,omitempty"`

	// auth Url asymmetric sign tlu
	AuthURLAsymmetricSignTlu []*CustconfAuthURLAsymmetricSignTlu `json:"authUrlAsymmetricSignTlu,omitempty"`

	// URL Signing policies allow you to restrict access to your content by
	// configuring a "shared secret" with Highwinds. This “shared secret” is
	// used to apply an MD5 hashing algorithm on the URL to validate the signature
	// supplied on the request.  Since the "shared secret" is only known by the
	// publisher and Highwinds, URL signatures cannot be generated by unauthorized
	// users.
	AuthURLSign []*CustconfAuthURLSign `json:"authUrlSign,omitempty"`

	// The Akamai URL Signing v1 policy allows you to create a signed URL that
	// implements the same signing method used by Akamai; therefore, published
	// URLs from an Akamai CDN network can be transitioned to the Highwinds
	// network without you having to change your signing methods.
	AuthURLSignAKv1 []*CustconfAuthURLSignAKv1 `json:"authUrlSignAKv1,omitempty"`

	// The Akamai URL Signing v2 policy allows you to create a signed URL that
	// implements the same signing method used by Akamai; therefore, published
	// URLs from an Akamai CDN network can be transitioned to the Highwinds
	// network without you having to change your signing methods.
	AuthURLSignAKv2 []*CustconfAuthURLSignAKv2 `json:"authUrlSignAKv2,omitempty"`

	// auth Url sign ali cloud a
	AuthURLSignAliCloudA []*CustconfAuthURLSignAliCloudA `json:"authUrlSignAliCloudA,omitempty"`

	// auth Url sign ali cloud b
	AuthURLSignAliCloudB []*CustconfAuthURLSignAliCloudB `json:"authUrlSignAliCloudB,omitempty"`

	// auth Url sign ali cloud c
	AuthURLSignAliCloudC []*CustconfAuthURLSignAliCloudC `json:"authUrlSignAliCloudC,omitempty"`

	// auth Url sign hmac tlu
	AuthURLSignHmacTlu []*CustconfAuthURLSignHmacTlu `json:"authUrlSignHmacTlu,omitempty"`

	// The Level 3 URL Signing policy allows you to create a signed URL that
	// implements the same signing method used by Level 3; therefore, published
	// URLs from an Level 3 CDN network can be transitioned to the Highwinds
	// network without you having to change your signing methods.
	AuthURLSignL3 []*CustconfAuthURLSignL3 `json:"authUrlSignL3,omitempty"`

	// The Limelight Networks URL signing policy allows you to create a signed URL
	// that implements the same signing method used by Limelight Networks;
	// therefore, published URLs from a Limelight CDN network can be transitioned
	// to the Highwinds network without you having to change your URLs (or the
	// signing process).
	AuthURLSignLMV []*CustconfAuthURLSignLMV `json:"authUrlSignLMV,omitempty"`

	// auth vhost lockout
	AuthVhostLockout *CustconfAuthVhostLockout `json:"authVhostLockout,omitempty"`

	// aws signed origin pull v4
	AwsSignedOriginPullV4 []*CustconfAwsSignedOriginPullV4 `json:"awsSignedOriginPullV4,omitempty"`

	// band width limit
	BandWidthLimit *CustconfBandWidthLimit `json:"bandWidthLimit,omitempty"`

	// band width rate limit units
	BandWidthRateLimitUnits *CustconfBandWidthRateLimitUnits `json:"bandWidthRateLimitUnits,omitempty"`

	// bandwidth rate limit
	BandwidthRateLimit *CustconfBandwidthRateLimit `json:"bandwidthRateLimit,omitempty"`

	// billable regions
	BillableRegions *CustconfBillableRegions `json:"billableRegions,omitempty"`

	// blocking origin pull mode
	BlockingOriginPullMode *CustconfBlockingOriginPullMode `json:"blockingOriginPullMode,omitempty"`

	// The browser caching policy allows you to control the browser caching
	// behavior of your assets independently from the CDN cache.  For example,
	// this policy allows you to set lower or higher TTLs for the browser than
	// those of the CDN cache.
	CacheControl []*CustconfCacheControl `json:"cacheControl,omitempty"`

	// cache key modification
	CacheKeyModification *CustconfCacheKeyModification `json:"cacheKeyModification,omitempty"`

	// client access
	ClientAccess *CustconfClientAccess `json:"clientAccess,omitempty"`

	// The clientKeepAlive policy allows you to specify how long you want the CDN
	// caching server to keep an client connection open after serving a request.
	ClientKeepAlive []*CustconfClientKeepAlive `json:"clientKeepAlive,omitempty"`

	// client request modification
	ClientRequestModification []*CustconfClientRequestModification `json:"clientRequestModification,omitempty"`

	// client request queue
	ClientRequestQueue *CustconfClientRequestQueue `json:"clientRequestQueue,omitempty"`

	// client response modification
	ClientResponseModification []*CustconfClientResponseModification `json:"clientResponseModification,omitempty"`

	// client response queue
	ClientResponseQueue *CustconfClientResponseQueue `json:"clientResponseQueue,omitempty"`

	// close half open connections
	CloseHalfOpenConnections *CustconfCloseHalfOpenConnections `json:"closeHalfOpenConnections,omitempty"`

	// compression
	Compression *CustconfCompression `json:"compression,omitempty"`

	// The consistent hashing policy allows you to customize the consistent
	// hashing algorithm used by Doppler.
	ConsistentHashing []*CustconfConsistentHashing `json:"consistentHashing,omitempty"`

	// The content disposition by HTTP header match policy allows you to control
	// the Content-Disposition delivered by the CDN using a pattern match against
	// the value of any HTTP header present in the request.  If you are using URL
	// query string parameters to control the Content-Disposition header (using
	// the Content Disposition by URL policy) then the Content-Disposition header
	// generated by this policy will not be used on that specific request.  A
	// typical use case for this policy is to set a different Content-Disposition
	// header based on the User-Agent in the request.
	ContentDispositionByHeader []*CustconfContentDispositionByHeader `json:"contentDispositionByHeader,omitempty"`

	// content disposition by URL
	ContentDispositionByURL *CustconfContentDispositionByURL `json:"contentDispositionByURL,omitempty"`

	// cookie behavior
	CookieBehavior []*CustconfCookieBehavior `json:"cookieBehavior,omitempty"`

	// cross domain
	CrossDomain *CustconfCrossDomain `json:"crossDomain,omitempty"`

	// cust config
	CustConfig *CustconfCustConfig `json:"custConfig,omitempty"`

	// custom header
	CustomHeader *CustconfCustomHeader `json:"customHeader,omitempty"`

	// The custom mime type policy allows you to map file extensions to specific
	// mime types for the CDN caching servers to use when delivering assets.  The
	// mime types you map using this policy may also be limited to specific
	// response codes to address scenarios in which the mime type changes based on
	// the response code.
	CustomMimeType []*CustconfCustomMimeType `json:"customMimeType,omitempty"`

	// customer
	Customer *CustconfCustomer `json:"customer,omitempty"`

	// delivery platforms
	DeliveryPlatforms *CustconfDeliveryPlatforms `json:"deliveryPlatforms,omitempty"`

	// device based dynamic content
	DeviceBasedDynamicContent *CustconfDeviceBasedDynamicContent `json:"deviceBasedDynamicContent,omitempty"`

	// dns ipv6
	DNSIPV6 *CustconfDNSIPV6 `json:"dnsIpv6,omitempty"`

	// dns override
	DNSOverride []*CustconfDNSOverride `json:"dnsOverride,omitempty"`

	// drain TCP send buffer
	DrainTCPSendBuffer *CustconfDrainTCPSendBuffer `json:"drainTCPSendBuffer,omitempty"`

	// Client response based on Rules.
	DynamicCacheRule []*CustconfDynamicCacheRule `json:"dynamicCacheRule,omitempty"`

	// The dynamic content caching policy allows you to specify a set of query
	// string and/or HTTP header key/value pairs that should create a unique cache
	// entry for a given URL.  This policy is useful when your origin returns
	// unique content for the same URL based on a set of query string parameters
	// provided in the request.
	DynamicContent []*CustconfDynamicContent `json:"dynamicContent,omitempty"`

	// dynamic origin
	DynamicOrigin *CustconfDynamicOrigin `json:"dynamicOrigin,omitempty"`

	// fail safe origin pull
	FailSafeOriginPull *CustconfFailSafeOriginPull `json:"failSafeOriginPull,omitempty"`

	// file segmentation
	FileSegmentation *CustconfFileSegmentation `json:"fileSegmentation,omitempty"`

	// flv
	Flv *CustconfFlv `json:"flv,omitempty"`

	// flv pseudo streaming
	FlvPseudoStreaming *CustconfFlvPseudoStreaming `json:"flvPseudoStreaming,omitempty"`

	// general
	General *CustconfGeneral `json:"general,omitempty"`

	// gzip origin pull
	GzipOriginPull *CustconfGzipOriginPull `json:"gzipOriginPull,omitempty"`

	// h2proxy caching
	H2proxyCaching *CustconfH2proxyCaching `json:"h2proxyCaching,omitempty"`

	// hash type
	HashType *CustconfHashType `json:"hashType,omitempty"`

	// http2 support
	Http2Support *CustconfHttp2Support `json:"http2Support,omitempty"`

	// http methods
	HTTPMethods *CustconfHTTPMethods `json:"httpMethods,omitempty"`

	// internal error
	InternalError *CustconfInternalError `json:"internalError,omitempty"`

	// The language code origin request rewrite policy allows you to rewrite
	// responses from your origin to 301 response codes such that you can re-issue
	// the request to your origin with a new request URL.  This policy was created
	// to specifically map language codes in a origin request URL to default
	// languages when a resource was not found on the origin.  NOTE: This policy
	// requires a custom script to be configured on the script engine.
	LanguageRedirect []*CustconfLanguageRedirect `json:"languageRedirect,omitempty"`

	// legacy xdomain
	LegacyXdomain *CustconfLegacyXdomain `json:"legacyXdomain,omitempty"`

	// live streaming
	LiveStreaming []*CustconfLiveStreaming `json:"liveStreaming,omitempty"`

	// memory cacheable
	MemoryCacheable *CustconfMemoryCacheable `json:"memoryCacheable,omitempty"`

	// Mid Tier Caching Configuration
	MidTierCaching []*CustconfMidTierCaching `json:"midTierCaching,omitempty"`

	// nrt reporting
	NrtReporting *CustconfNrtReporting `json:"nrtReporting,omitempty"`

	// origin
	Origin []*CdncustconfOrigin `json:"origin,omitempty"`

	// origin persistent connections
	OriginPersistentConnections *CustconfOriginPersistentConnections `json:"originPersistentConnections,omitempty"`

	// origin pull
	OriginPull *CustconfOriginPull `json:"originPull,omitempty"`

	// origin pull cache extension
	OriginPullCacheExtension *CustconfOriginPullCacheExtension `json:"originPullCacheExtension,omitempty"`

	// origin pull host
	OriginPullHost []*CustconfOriginPullHost `json:"originPullHost,omitempty"`

	// origin pull logs
	OriginPullLogs *CustconfOriginPullLogs `json:"originPullLogs,omitempty"`

	// origin pull logs config
	OriginPullLogsConfig *CustconfOriginPullLogsConfig `json:"originPullLogsConfig,omitempty"`

	// The CDN caching policy allows you to control how your origin's content is
	// cached on the CDN.
	OriginPullPolicy []*CustconfOriginPullPolicy `json:"originPullPolicy,omitempty"`

	// origin pull pops
	OriginPullPops []*CustconfOriginPullPops `json:"originPullPops,omitempty"`

	// origin pull protocol
	OriginPullProtocol *CustconfOriginPullProtocol `json:"originPullProtocol,omitempty"`

	// origin pull shield
	OriginPullShield *CustconfOriginPullShield `json:"originPullShield,omitempty"`

	// origin pull shield override
	OriginPullShieldOverride *CustconfOriginPullShieldOverride `json:"originPullShieldOverride,omitempty"`

	// origin request modification
	OriginRequestModification []*CustconfOriginRequestModification `json:"originRequestModification,omitempty"`

	// origin request queue
	OriginRequestQueue *CustconfOriginRequestQueue `json:"originRequestQueue,omitempty"`

	// origin response modification
	OriginResponseModification []*CustconfOriginResponseModification `json:"originResponseModification,omitempty"`

	// origin response queue
	OriginResponseQueue *CustconfOriginResponseQueue `json:"originResponseQueue,omitempty"`

	// Request URL rewriting policies can be used to modify the URL path of a CDN
	// request.  This policy requires a custom script to be configured.
	// This policy requires the Script Engine service enabled on your account. If
	// you do not have this service enabled, please contact your sales
	// representative for more information.
	PathModification []*CustconfPathModification `json:"pathModification,omitempty"`

	// preserve redirect host
	PreserveRedirectHost *CustconfPreserveRedirectHost `json:"preserveRedirectHost,omitempty"`

	// query str param
	QueryStrParam *CustconfQueryStrParam `json:"queryStrParam,omitempty"`

	// receipt logs
	ReceiptLogs *CustconfReceiptLogs `json:"receiptLogs,omitempty"`

	// receipt logs config
	ReceiptLogsConfig *CustconfReceiptLogsConfig `json:"receiptLogsConfig,omitempty"`

	// redirect exceptions
	RedirectExceptions *CustconfRedirectExceptions `json:"redirectExceptions,omitempty"`

	// The response code redirection policy allows you to map cache response codes
	// to an HTTP redirect response.  When this policy is applied to a host, the
	// caching servers will redirect clients to the URL specified in this policy
	// instead of delivering the response code you mapped in the policy.
	RedirectMappings []*CustconfRedirectMappings `json:"redirectMappings,omitempty"`

	// request filter
	RequestFilter []*CustconfRequestFilter `json:"requestFilter,omitempty"`

	// request receipt
	RequestReceipt []*CustconfRequestReceipt `json:"requestReceipt,omitempty"`

	// request receipt report percentage
	RequestReceiptReportPercentage *CustconfRequestReceiptReportPercentage `json:"requestReceiptReportPercentage,omitempty"`

	// request receipt server
	RequestReceiptServer []*CustconfRequestReceiptServer `json:"requestReceiptServer,omitempty"`

	// response filter
	ResponseFilter []*CustconfResponseFilter `json:"responseFilter,omitempty"`

	// response header
	ResponseHeader *CustconfResponseHeader `json:"responseHeader,omitempty"`

	// robots txt
	RobotsTxt []*CustconfRobotsTxt `json:"robotsTxt,omitempty"`

	// script neg caching
	ScriptNegCaching *CustconfScriptNegCaching `json:"scriptNegCaching,omitempty"`

	// Serverless Script Processing is currently under development and will only
	// be used in limited testing.
	ServerlessScripting []*CustconfServerlessScripting `json:"serverlessScripting,omitempty"`

	// The static header injection policy allows you to insert headers into the
	// CDN request and response processor.
	StaticHeader []*CustconfStaticHeader `json:"staticHeader,omitempty"`

	// stream chunked encoding response
	StreamChunkedEncodingResponse *CustconfStreamChunkedEncodingResponse `json:"streamChunkedEncodingResponse,omitempty"`

	// test policy one
	TestPolicyOne *CustconfTestPolicyOne `json:"testPolicyOne,omitempty"`

	// test policy two
	TestPolicyTwo *CustconfTestPolicyTwo `json:"testPolicyTwo,omitempty"`

	// time pseudo streaming
	TimePseudoStreaming *CustconfTimePseudoStreaming `json:"timePseudoStreaming,omitempty"`

	// tossback always
	TossbackAlways *CustconfTossbackAlways `json:"tossbackAlways,omitempty"`

	// tossback bypass
	TossbackBypass *CustconfTossbackBypass `json:"tossbackBypass,omitempty"`

	// A hostname policy allows you to specify an alternate domain name that you
	// want to use to access content from your CDN container.
	VHost []*CustconfVHost `json:"vHost,omitempty"`

	// vary header field
	VaryHeaderField *CustconfVaryHeaderField `json:"varyHeaderField,omitempty"`

	// waf
	Waf []*CustconfWaf `json:"waf,omitempty"`

	// waf clusters override
	WafClustersOverride []*CustconfWafClustersOverride `json:"wafClustersOverride,omitempty"`

	// x forwarded for behavior
	XForwardedForBehavior *CustconfXForwardedForBehavior `json:"xForwardedForBehavior,omitempty"`
}

// Validate validates this custconf configuration
func (m *CustconfConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessLogIPObfuscation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessLogger(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessLogsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthGeo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthHTTPBasic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthReferer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthSignUrlsInPlaylist(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLAsymmetricSignTlu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSign(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAKv1(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAKv2(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAliCloudA(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAliCloudB(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAliCloudC(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignHmacTlu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignL3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignLMV(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthVhostLockout(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsSignedOriginPullV4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBandWidthLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBandWidthRateLimitUnits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBandwidthRateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBillableRegions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockingOriginPullMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheKeyModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientAccess(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientKeepAlive(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientRequestModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientRequestQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientResponseModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientResponseQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloseHalfOpenConnections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConsistentHashing(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentDispositionByHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentDispositionByURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCookieBehavior(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCrossDomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomMimeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeliveryPlatforms(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeviceBasedDynamicContent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSIPV6(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDrainTCPSendBuffer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicCacheRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicContent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailSafeOriginPull(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileSegmentation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlvPseudoStreaming(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeneral(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGzipOriginPull(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateH2proxyCaching(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHttp2Support(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHTTPMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateInternalError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLanguageRedirect(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLegacyXdomain(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLiveStreaming(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoryCacheable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMidTierCaching(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNrtReporting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPersistentConnections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPull(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullCacheExtension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullLogsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullPops(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullShield(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullShieldOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginRequestModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginRequestQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginResponseModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginResponseQueue(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePathModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePreserveRedirectHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryStrParam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptLogsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedirectExceptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedirectMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestReceipt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestReceiptReportPercentage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequestReceiptServer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseFilter(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRobotsTxt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScriptNegCaching(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServerlessScripting(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStaticHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStreamChunkedEncodingResponse(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestPolicyOne(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTestPolicyTwo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimePseudoStreaming(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTossbackAlways(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTossbackBypass(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaryHeaderField(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWaf(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWafClustersOverride(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateXForwardedForBehavior(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustconfConfiguration) validateAccessLogIPObfuscation(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessLogIPObfuscation) { // not required
		return nil
	}

	if m.AccessLogIPObfuscation != nil {
		if err := m.AccessLogIPObfuscation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogIpObfuscation")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAccessLogger(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessLogger) { // not required
		return nil
	}

	if m.AccessLogger != nil {
		if err := m.AccessLogger.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogger")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAccessLogs(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessLogs) { // not required
		return nil
	}

	if m.AccessLogs != nil {
		if err := m.AccessLogs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAccessLogsConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessLogsConfig) { // not required
		return nil
	}

	if m.AccessLogsConfig != nil {
		if err := m.AccessLogsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAccount(formats strfmt.Registry) error {

	if swag.IsZero(m.Account) { // not required
		return nil
	}

	if m.Account != nil {
		if err := m.Account.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("account")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthACL(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthACL) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthACL); i++ {
		if swag.IsZero(m.AuthACL[i]) { // not required
			continue
		}

		if m.AuthACL[i] != nil {
			if err := m.AuthACL[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authACL" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthGeo(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthGeo) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthGeo); i++ {
		if swag.IsZero(m.AuthGeo[i]) { // not required
			continue
		}

		if m.AuthGeo[i] != nil {
			if err := m.AuthGeo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authGeo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthHTTPBasic(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthHTTPBasic) { // not required
		return nil
	}

	if m.AuthHTTPBasic != nil {
		if err := m.AuthHTTPBasic.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authHttpBasic")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthReferer(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthReferer) { // not required
		return nil
	}

	if m.AuthReferer != nil {
		if err := m.AuthReferer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authReferer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthSignUrlsInPlaylist(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthSignUrlsInPlaylist) { // not required
		return nil
	}

	if m.AuthSignUrlsInPlaylist != nil {
		if err := m.AuthSignUrlsInPlaylist.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authSignUrlsInPlaylist")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLAsymmetricSignTlu(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLAsymmetricSignTlu) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLAsymmetricSignTlu); i++ {
		if swag.IsZero(m.AuthURLAsymmetricSignTlu[i]) { // not required
			continue
		}

		if m.AuthURLAsymmetricSignTlu[i] != nil {
			if err := m.AuthURLAsymmetricSignTlu[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlAsymmetricSignTlu" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSign(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSign) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSign); i++ {
		if swag.IsZero(m.AuthURLSign[i]) { // not required
			continue
		}

		if m.AuthURLSign[i] != nil {
			if err := m.AuthURLSign[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSign" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAKv1(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignAKv1) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAKv1); i++ {
		if swag.IsZero(m.AuthURLSignAKv1[i]) { // not required
			continue
		}

		if m.AuthURLSignAKv1[i] != nil {
			if err := m.AuthURLSignAKv1[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAKv1" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAKv2(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignAKv2) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAKv2); i++ {
		if swag.IsZero(m.AuthURLSignAKv2[i]) { // not required
			continue
		}

		if m.AuthURLSignAKv2[i] != nil {
			if err := m.AuthURLSignAKv2[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAKv2" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAliCloudA(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignAliCloudA) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAliCloudA); i++ {
		if swag.IsZero(m.AuthURLSignAliCloudA[i]) { // not required
			continue
		}

		if m.AuthURLSignAliCloudA[i] != nil {
			if err := m.AuthURLSignAliCloudA[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudA" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAliCloudB(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignAliCloudB) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAliCloudB); i++ {
		if swag.IsZero(m.AuthURLSignAliCloudB[i]) { // not required
			continue
		}

		if m.AuthURLSignAliCloudB[i] != nil {
			if err := m.AuthURLSignAliCloudB[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudB" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAliCloudC(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignAliCloudC) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAliCloudC); i++ {
		if swag.IsZero(m.AuthURLSignAliCloudC[i]) { // not required
			continue
		}

		if m.AuthURLSignAliCloudC[i] != nil {
			if err := m.AuthURLSignAliCloudC[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudC" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignHmacTlu(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignHmacTlu) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignHmacTlu); i++ {
		if swag.IsZero(m.AuthURLSignHmacTlu[i]) { // not required
			continue
		}

		if m.AuthURLSignHmacTlu[i] != nil {
			if err := m.AuthURLSignHmacTlu[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignHmacTlu" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignL3(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignL3) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignL3); i++ {
		if swag.IsZero(m.AuthURLSignL3[i]) { // not required
			continue
		}

		if m.AuthURLSignL3[i] != nil {
			if err := m.AuthURLSignL3[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignL3" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignLMV(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthURLSignLMV) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignLMV); i++ {
		if swag.IsZero(m.AuthURLSignLMV[i]) { // not required
			continue
		}

		if m.AuthURLSignLMV[i] != nil {
			if err := m.AuthURLSignLMV[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignLMV" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthVhostLockout(formats strfmt.Registry) error {

	if swag.IsZero(m.AuthVhostLockout) { // not required
		return nil
	}

	if m.AuthVhostLockout != nil {
		if err := m.AuthVhostLockout.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authVhostLockout")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAwsSignedOriginPullV4(formats strfmt.Registry) error {

	if swag.IsZero(m.AwsSignedOriginPullV4) { // not required
		return nil
	}

	for i := 0; i < len(m.AwsSignedOriginPullV4); i++ {
		if swag.IsZero(m.AwsSignedOriginPullV4[i]) { // not required
			continue
		}

		if m.AwsSignedOriginPullV4[i] != nil {
			if err := m.AwsSignedOriginPullV4[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("awsSignedOriginPullV4" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateBandWidthLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.BandWidthLimit) { // not required
		return nil
	}

	if m.BandWidthLimit != nil {
		if err := m.BandWidthLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandWidthLimit")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateBandWidthRateLimitUnits(formats strfmt.Registry) error {

	if swag.IsZero(m.BandWidthRateLimitUnits) { // not required
		return nil
	}

	if m.BandWidthRateLimitUnits != nil {
		if err := m.BandWidthRateLimitUnits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandWidthRateLimitUnits")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateBandwidthRateLimit(formats strfmt.Registry) error {

	if swag.IsZero(m.BandwidthRateLimit) { // not required
		return nil
	}

	if m.BandwidthRateLimit != nil {
		if err := m.BandwidthRateLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidthRateLimit")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateBillableRegions(formats strfmt.Registry) error {

	if swag.IsZero(m.BillableRegions) { // not required
		return nil
	}

	if m.BillableRegions != nil {
		if err := m.BillableRegions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("billableRegions")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateBlockingOriginPullMode(formats strfmt.Registry) error {

	if swag.IsZero(m.BlockingOriginPullMode) { // not required
		return nil
	}

	if m.BlockingOriginPullMode != nil {
		if err := m.BlockingOriginPullMode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("blockingOriginPullMode")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCacheControl(formats strfmt.Registry) error {

	if swag.IsZero(m.CacheControl) { // not required
		return nil
	}

	for i := 0; i < len(m.CacheControl); i++ {
		if swag.IsZero(m.CacheControl[i]) { // not required
			continue
		}

		if m.CacheControl[i] != nil {
			if err := m.CacheControl[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cacheControl" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateCacheKeyModification(formats strfmt.Registry) error {

	if swag.IsZero(m.CacheKeyModification) { // not required
		return nil
	}

	if m.CacheKeyModification != nil {
		if err := m.CacheKeyModification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cacheKeyModification")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateClientAccess(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientAccess) { // not required
		return nil
	}

	if m.ClientAccess != nil {
		if err := m.ClientAccess.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientAccess")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateClientKeepAlive(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientKeepAlive) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientKeepAlive); i++ {
		if swag.IsZero(m.ClientKeepAlive[i]) { // not required
			continue
		}

		if m.ClientKeepAlive[i] != nil {
			if err := m.ClientKeepAlive[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientKeepAlive" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateClientRequestModification(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientRequestModification) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientRequestModification); i++ {
		if swag.IsZero(m.ClientRequestModification[i]) { // not required
			continue
		}

		if m.ClientRequestModification[i] != nil {
			if err := m.ClientRequestModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientRequestModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateClientRequestQueue(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientRequestQueue) { // not required
		return nil
	}

	if m.ClientRequestQueue != nil {
		if err := m.ClientRequestQueue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientRequestQueue")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateClientResponseModification(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientResponseModification) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientResponseModification); i++ {
		if swag.IsZero(m.ClientResponseModification[i]) { // not required
			continue
		}

		if m.ClientResponseModification[i] != nil {
			if err := m.ClientResponseModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientResponseModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateClientResponseQueue(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientResponseQueue) { // not required
		return nil
	}

	if m.ClientResponseQueue != nil {
		if err := m.ClientResponseQueue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("clientResponseQueue")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCloseHalfOpenConnections(formats strfmt.Registry) error {

	if swag.IsZero(m.CloseHalfOpenConnections) { // not required
		return nil
	}

	if m.CloseHalfOpenConnections != nil {
		if err := m.CloseHalfOpenConnections.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("closeHalfOpenConnections")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCompression(formats strfmt.Registry) error {

	if swag.IsZero(m.Compression) { // not required
		return nil
	}

	if m.Compression != nil {
		if err := m.Compression.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("compression")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateConsistentHashing(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsistentHashing) { // not required
		return nil
	}

	for i := 0; i < len(m.ConsistentHashing); i++ {
		if swag.IsZero(m.ConsistentHashing[i]) { // not required
			continue
		}

		if m.ConsistentHashing[i] != nil {
			if err := m.ConsistentHashing[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("consistentHashing" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateContentDispositionByHeader(formats strfmt.Registry) error {

	if swag.IsZero(m.ContentDispositionByHeader) { // not required
		return nil
	}

	for i := 0; i < len(m.ContentDispositionByHeader); i++ {
		if swag.IsZero(m.ContentDispositionByHeader[i]) { // not required
			continue
		}

		if m.ContentDispositionByHeader[i] != nil {
			if err := m.ContentDispositionByHeader[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentDispositionByHeader" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateContentDispositionByURL(formats strfmt.Registry) error {

	if swag.IsZero(m.ContentDispositionByURL) { // not required
		return nil
	}

	if m.ContentDispositionByURL != nil {
		if err := m.ContentDispositionByURL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contentDispositionByURL")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCookieBehavior(formats strfmt.Registry) error {

	if swag.IsZero(m.CookieBehavior) { // not required
		return nil
	}

	for i := 0; i < len(m.CookieBehavior); i++ {
		if swag.IsZero(m.CookieBehavior[i]) { // not required
			continue
		}

		if m.CookieBehavior[i] != nil {
			if err := m.CookieBehavior[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cookieBehavior" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateCrossDomain(formats strfmt.Registry) error {

	if swag.IsZero(m.CrossDomain) { // not required
		return nil
	}

	if m.CrossDomain != nil {
		if err := m.CrossDomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("crossDomain")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCustConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.CustConfig) { // not required
		return nil
	}

	if m.CustConfig != nil {
		if err := m.CustConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCustomHeader(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomHeader) { // not required
		return nil
	}

	if m.CustomHeader != nil {
		if err := m.CustomHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customHeader")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCustomMimeType(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomMimeType) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomMimeType); i++ {
		if swag.IsZero(m.CustomMimeType[i]) { // not required
			continue
		}

		if m.CustomMimeType[i] != nil {
			if err := m.CustomMimeType[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customMimeType" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateCustomer(formats strfmt.Registry) error {

	if swag.IsZero(m.Customer) { // not required
		return nil
	}

	if m.Customer != nil {
		if err := m.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateDeliveryPlatforms(formats strfmt.Registry) error {

	if swag.IsZero(m.DeliveryPlatforms) { // not required
		return nil
	}

	if m.DeliveryPlatforms != nil {
		if err := m.DeliveryPlatforms.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deliveryPlatforms")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateDeviceBasedDynamicContent(formats strfmt.Registry) error {

	if swag.IsZero(m.DeviceBasedDynamicContent) { // not required
		return nil
	}

	if m.DeviceBasedDynamicContent != nil {
		if err := m.DeviceBasedDynamicContent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deviceBasedDynamicContent")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateDNSIPV6(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSIPV6) { // not required
		return nil
	}

	if m.DNSIPV6 != nil {
		if err := m.DNSIPV6.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dnsIpv6")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateDNSOverride(formats strfmt.Registry) error {

	if swag.IsZero(m.DNSOverride) { // not required
		return nil
	}

	for i := 0; i < len(m.DNSOverride); i++ {
		if swag.IsZero(m.DNSOverride[i]) { // not required
			continue
		}

		if m.DNSOverride[i] != nil {
			if err := m.DNSOverride[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dnsOverride" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateDrainTCPSendBuffer(formats strfmt.Registry) error {

	if swag.IsZero(m.DrainTCPSendBuffer) { // not required
		return nil
	}

	if m.DrainTCPSendBuffer != nil {
		if err := m.DrainTCPSendBuffer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("drainTCPSendBuffer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateDynamicCacheRule(formats strfmt.Registry) error {

	if swag.IsZero(m.DynamicCacheRule) { // not required
		return nil
	}

	for i := 0; i < len(m.DynamicCacheRule); i++ {
		if swag.IsZero(m.DynamicCacheRule[i]) { // not required
			continue
		}

		if m.DynamicCacheRule[i] != nil {
			if err := m.DynamicCacheRule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicCacheRule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateDynamicContent(formats strfmt.Registry) error {

	if swag.IsZero(m.DynamicContent) { // not required
		return nil
	}

	for i := 0; i < len(m.DynamicContent); i++ {
		if swag.IsZero(m.DynamicContent[i]) { // not required
			continue
		}

		if m.DynamicContent[i] != nil {
			if err := m.DynamicContent[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicContent" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateDynamicOrigin(formats strfmt.Registry) error {

	if swag.IsZero(m.DynamicOrigin) { // not required
		return nil
	}

	if m.DynamicOrigin != nil {
		if err := m.DynamicOrigin.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("dynamicOrigin")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFailSafeOriginPull(formats strfmt.Registry) error {

	if swag.IsZero(m.FailSafeOriginPull) { // not required
		return nil
	}

	if m.FailSafeOriginPull != nil {
		if err := m.FailSafeOriginPull.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failSafeOriginPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFileSegmentation(formats strfmt.Registry) error {

	if swag.IsZero(m.FileSegmentation) { // not required
		return nil
	}

	if m.FileSegmentation != nil {
		if err := m.FileSegmentation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileSegmentation")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFlv(formats strfmt.Registry) error {

	if swag.IsZero(m.Flv) { // not required
		return nil
	}

	if m.Flv != nil {
		if err := m.Flv.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flv")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFlvPseudoStreaming(formats strfmt.Registry) error {

	if swag.IsZero(m.FlvPseudoStreaming) { // not required
		return nil
	}

	if m.FlvPseudoStreaming != nil {
		if err := m.FlvPseudoStreaming.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flvPseudoStreaming")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateGeneral(formats strfmt.Registry) error {

	if swag.IsZero(m.General) { // not required
		return nil
	}

	if m.General != nil {
		if err := m.General.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("general")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateGzipOriginPull(formats strfmt.Registry) error {

	if swag.IsZero(m.GzipOriginPull) { // not required
		return nil
	}

	if m.GzipOriginPull != nil {
		if err := m.GzipOriginPull.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gzipOriginPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateH2proxyCaching(formats strfmt.Registry) error {

	if swag.IsZero(m.H2proxyCaching) { // not required
		return nil
	}

	if m.H2proxyCaching != nil {
		if err := m.H2proxyCaching.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("h2proxyCaching")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateHashType(formats strfmt.Registry) error {

	if swag.IsZero(m.HashType) { // not required
		return nil
	}

	if m.HashType != nil {
		if err := m.HashType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("hashType")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateHttp2Support(formats strfmt.Registry) error {

	if swag.IsZero(m.Http2Support) { // not required
		return nil
	}

	if m.Http2Support != nil {
		if err := m.Http2Support.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("http2Support")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateHTTPMethods(formats strfmt.Registry) error {

	if swag.IsZero(m.HTTPMethods) { // not required
		return nil
	}

	if m.HTTPMethods != nil {
		if err := m.HTTPMethods.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("httpMethods")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateInternalError(formats strfmt.Registry) error {

	if swag.IsZero(m.InternalError) { // not required
		return nil
	}

	if m.InternalError != nil {
		if err := m.InternalError.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("internalError")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateLanguageRedirect(formats strfmt.Registry) error {

	if swag.IsZero(m.LanguageRedirect) { // not required
		return nil
	}

	for i := 0; i < len(m.LanguageRedirect); i++ {
		if swag.IsZero(m.LanguageRedirect[i]) { // not required
			continue
		}

		if m.LanguageRedirect[i] != nil {
			if err := m.LanguageRedirect[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("languageRedirect" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateLegacyXdomain(formats strfmt.Registry) error {

	if swag.IsZero(m.LegacyXdomain) { // not required
		return nil
	}

	if m.LegacyXdomain != nil {
		if err := m.LegacyXdomain.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("legacyXdomain")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateLiveStreaming(formats strfmt.Registry) error {

	if swag.IsZero(m.LiveStreaming) { // not required
		return nil
	}

	for i := 0; i < len(m.LiveStreaming); i++ {
		if swag.IsZero(m.LiveStreaming[i]) { // not required
			continue
		}

		if m.LiveStreaming[i] != nil {
			if err := m.LiveStreaming[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("liveStreaming" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateMemoryCacheable(formats strfmt.Registry) error {

	if swag.IsZero(m.MemoryCacheable) { // not required
		return nil
	}

	if m.MemoryCacheable != nil {
		if err := m.MemoryCacheable.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoryCacheable")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateMidTierCaching(formats strfmt.Registry) error {

	if swag.IsZero(m.MidTierCaching) { // not required
		return nil
	}

	for i := 0; i < len(m.MidTierCaching); i++ {
		if swag.IsZero(m.MidTierCaching[i]) { // not required
			continue
		}

		if m.MidTierCaching[i] != nil {
			if err := m.MidTierCaching[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("midTierCaching" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateNrtReporting(formats strfmt.Registry) error {

	if swag.IsZero(m.NrtReporting) { // not required
		return nil
	}

	if m.NrtReporting != nil {
		if err := m.NrtReporting.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("nrtReporting")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOrigin(formats strfmt.Registry) error {

	if swag.IsZero(m.Origin) { // not required
		return nil
	}

	for i := 0; i < len(m.Origin); i++ {
		if swag.IsZero(m.Origin[i]) { // not required
			continue
		}

		if m.Origin[i] != nil {
			if err := m.Origin[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("origin" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPersistentConnections(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPersistentConnections) { // not required
		return nil
	}

	if m.OriginPersistentConnections != nil {
		if err := m.OriginPersistentConnections.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPersistentConnections")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPull(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPull) { // not required
		return nil
	}

	if m.OriginPull != nil {
		if err := m.OriginPull.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullCacheExtension(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullCacheExtension) { // not required
		return nil
	}

	if m.OriginPullCacheExtension != nil {
		if err := m.OriginPullCacheExtension.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullCacheExtension")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullHost(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullHost) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginPullHost); i++ {
		if swag.IsZero(m.OriginPullHost[i]) { // not required
			continue
		}

		if m.OriginPullHost[i] != nil {
			if err := m.OriginPullHost[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullHost" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullLogs(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullLogs) { // not required
		return nil
	}

	if m.OriginPullLogs != nil {
		if err := m.OriginPullLogs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullLogsConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullLogsConfig) { // not required
		return nil
	}

	if m.OriginPullLogsConfig != nil {
		if err := m.OriginPullLogsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullPolicy) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginPullPolicy); i++ {
		if swag.IsZero(m.OriginPullPolicy[i]) { // not required
			continue
		}

		if m.OriginPullPolicy[i] != nil {
			if err := m.OriginPullPolicy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullPolicy" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullPops(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullPops) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginPullPops); i++ {
		if swag.IsZero(m.OriginPullPops[i]) { // not required
			continue
		}

		if m.OriginPullPops[i] != nil {
			if err := m.OriginPullPops[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullPops" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullProtocol) { // not required
		return nil
	}

	if m.OriginPullProtocol != nil {
		if err := m.OriginPullProtocol.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullProtocol")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullShield(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullShield) { // not required
		return nil
	}

	if m.OriginPullShield != nil {
		if err := m.OriginPullShield.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullShield")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullShieldOverride(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginPullShieldOverride) { // not required
		return nil
	}

	if m.OriginPullShieldOverride != nil {
		if err := m.OriginPullShieldOverride.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullShieldOverride")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginRequestModification(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginRequestModification) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginRequestModification); i++ {
		if swag.IsZero(m.OriginRequestModification[i]) { // not required
			continue
		}

		if m.OriginRequestModification[i] != nil {
			if err := m.OriginRequestModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originRequestModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginRequestQueue(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginRequestQueue) { // not required
		return nil
	}

	if m.OriginRequestQueue != nil {
		if err := m.OriginRequestQueue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originRequestQueue")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginResponseModification(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginResponseModification) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginResponseModification); i++ {
		if swag.IsZero(m.OriginResponseModification[i]) { // not required
			continue
		}

		if m.OriginResponseModification[i] != nil {
			if err := m.OriginResponseModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originResponseModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginResponseQueue(formats strfmt.Registry) error {

	if swag.IsZero(m.OriginResponseQueue) { // not required
		return nil
	}

	if m.OriginResponseQueue != nil {
		if err := m.OriginResponseQueue.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originResponseQueue")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validatePathModification(formats strfmt.Registry) error {

	if swag.IsZero(m.PathModification) { // not required
		return nil
	}

	for i := 0; i < len(m.PathModification); i++ {
		if swag.IsZero(m.PathModification[i]) { // not required
			continue
		}

		if m.PathModification[i] != nil {
			if err := m.PathModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("pathModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validatePreserveRedirectHost(formats strfmt.Registry) error {

	if swag.IsZero(m.PreserveRedirectHost) { // not required
		return nil
	}

	if m.PreserveRedirectHost != nil {
		if err := m.PreserveRedirectHost.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("preserveRedirectHost")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateQueryStrParam(formats strfmt.Registry) error {

	if swag.IsZero(m.QueryStrParam) { // not required
		return nil
	}

	if m.QueryStrParam != nil {
		if err := m.QueryStrParam.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryStrParam")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateReceiptLogs(formats strfmt.Registry) error {

	if swag.IsZero(m.ReceiptLogs) { // not required
		return nil
	}

	if m.ReceiptLogs != nil {
		if err := m.ReceiptLogs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("receiptLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateReceiptLogsConfig(formats strfmt.Registry) error {

	if swag.IsZero(m.ReceiptLogsConfig) { // not required
		return nil
	}

	if m.ReceiptLogsConfig != nil {
		if err := m.ReceiptLogsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("receiptLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRedirectExceptions(formats strfmt.Registry) error {

	if swag.IsZero(m.RedirectExceptions) { // not required
		return nil
	}

	if m.RedirectExceptions != nil {
		if err := m.RedirectExceptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("redirectExceptions")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRedirectMappings(formats strfmt.Registry) error {

	if swag.IsZero(m.RedirectMappings) { // not required
		return nil
	}

	for i := 0; i < len(m.RedirectMappings); i++ {
		if swag.IsZero(m.RedirectMappings[i]) { // not required
			continue
		}

		if m.RedirectMappings[i] != nil {
			if err := m.RedirectMappings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("redirectMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateRequestFilter(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestFilter) { // not required
		return nil
	}

	for i := 0; i < len(m.RequestFilter); i++ {
		if swag.IsZero(m.RequestFilter[i]) { // not required
			continue
		}

		if m.RequestFilter[i] != nil {
			if err := m.RequestFilter[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requestFilter" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateRequestReceipt(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestReceipt) { // not required
		return nil
	}

	for i := 0; i < len(m.RequestReceipt); i++ {
		if swag.IsZero(m.RequestReceipt[i]) { // not required
			continue
		}

		if m.RequestReceipt[i] != nil {
			if err := m.RequestReceipt[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requestReceipt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateRequestReceiptReportPercentage(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestReceiptReportPercentage) { // not required
		return nil
	}

	if m.RequestReceiptReportPercentage != nil {
		if err := m.RequestReceiptReportPercentage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("requestReceiptReportPercentage")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRequestReceiptServer(formats strfmt.Registry) error {

	if swag.IsZero(m.RequestReceiptServer) { // not required
		return nil
	}

	for i := 0; i < len(m.RequestReceiptServer); i++ {
		if swag.IsZero(m.RequestReceiptServer[i]) { // not required
			continue
		}

		if m.RequestReceiptServer[i] != nil {
			if err := m.RequestReceiptServer[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("requestReceiptServer" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateResponseFilter(formats strfmt.Registry) error {

	if swag.IsZero(m.ResponseFilter) { // not required
		return nil
	}

	for i := 0; i < len(m.ResponseFilter); i++ {
		if swag.IsZero(m.ResponseFilter[i]) { // not required
			continue
		}

		if m.ResponseFilter[i] != nil {
			if err := m.ResponseFilter[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("responseFilter" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateResponseHeader(formats strfmt.Registry) error {

	if swag.IsZero(m.ResponseHeader) { // not required
		return nil
	}

	if m.ResponseHeader != nil {
		if err := m.ResponseHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("responseHeader")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRobotsTxt(formats strfmt.Registry) error {

	if swag.IsZero(m.RobotsTxt) { // not required
		return nil
	}

	for i := 0; i < len(m.RobotsTxt); i++ {
		if swag.IsZero(m.RobotsTxt[i]) { // not required
			continue
		}

		if m.RobotsTxt[i] != nil {
			if err := m.RobotsTxt[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("robotsTxt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateScriptNegCaching(formats strfmt.Registry) error {

	if swag.IsZero(m.ScriptNegCaching) { // not required
		return nil
	}

	if m.ScriptNegCaching != nil {
		if err := m.ScriptNegCaching.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("scriptNegCaching")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateServerlessScripting(formats strfmt.Registry) error {

	if swag.IsZero(m.ServerlessScripting) { // not required
		return nil
	}

	for i := 0; i < len(m.ServerlessScripting); i++ {
		if swag.IsZero(m.ServerlessScripting[i]) { // not required
			continue
		}

		if m.ServerlessScripting[i] != nil {
			if err := m.ServerlessScripting[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serverlessScripting" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateStaticHeader(formats strfmt.Registry) error {

	if swag.IsZero(m.StaticHeader) { // not required
		return nil
	}

	for i := 0; i < len(m.StaticHeader); i++ {
		if swag.IsZero(m.StaticHeader[i]) { // not required
			continue
		}

		if m.StaticHeader[i] != nil {
			if err := m.StaticHeader[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("staticHeader" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateStreamChunkedEncodingResponse(formats strfmt.Registry) error {

	if swag.IsZero(m.StreamChunkedEncodingResponse) { // not required
		return nil
	}

	if m.StreamChunkedEncodingResponse != nil {
		if err := m.StreamChunkedEncodingResponse.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("streamChunkedEncodingResponse")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateTestPolicyOne(formats strfmt.Registry) error {

	if swag.IsZero(m.TestPolicyOne) { // not required
		return nil
	}

	if m.TestPolicyOne != nil {
		if err := m.TestPolicyOne.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("testPolicyOne")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateTestPolicyTwo(formats strfmt.Registry) error {

	if swag.IsZero(m.TestPolicyTwo) { // not required
		return nil
	}

	if m.TestPolicyTwo != nil {
		if err := m.TestPolicyTwo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("testPolicyTwo")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateTimePseudoStreaming(formats strfmt.Registry) error {

	if swag.IsZero(m.TimePseudoStreaming) { // not required
		return nil
	}

	if m.TimePseudoStreaming != nil {
		if err := m.TimePseudoStreaming.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timePseudoStreaming")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateTossbackAlways(formats strfmt.Registry) error {

	if swag.IsZero(m.TossbackAlways) { // not required
		return nil
	}

	if m.TossbackAlways != nil {
		if err := m.TossbackAlways.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tossbackAlways")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateTossbackBypass(formats strfmt.Registry) error {

	if swag.IsZero(m.TossbackBypass) { // not required
		return nil
	}

	if m.TossbackBypass != nil {
		if err := m.TossbackBypass.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tossbackBypass")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateVHost(formats strfmt.Registry) error {

	if swag.IsZero(m.VHost) { // not required
		return nil
	}

	for i := 0; i < len(m.VHost); i++ {
		if swag.IsZero(m.VHost[i]) { // not required
			continue
		}

		if m.VHost[i] != nil {
			if err := m.VHost[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vHost" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateVaryHeaderField(formats strfmt.Registry) error {

	if swag.IsZero(m.VaryHeaderField) { // not required
		return nil
	}

	if m.VaryHeaderField != nil {
		if err := m.VaryHeaderField.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("varyHeaderField")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateWaf(formats strfmt.Registry) error {

	if swag.IsZero(m.Waf) { // not required
		return nil
	}

	for i := 0; i < len(m.Waf); i++ {
		if swag.IsZero(m.Waf[i]) { // not required
			continue
		}

		if m.Waf[i] != nil {
			if err := m.Waf[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("waf" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateWafClustersOverride(formats strfmt.Registry) error {

	if swag.IsZero(m.WafClustersOverride) { // not required
		return nil
	}

	for i := 0; i < len(m.WafClustersOverride); i++ {
		if swag.IsZero(m.WafClustersOverride[i]) { // not required
			continue
		}

		if m.WafClustersOverride[i] != nil {
			if err := m.WafClustersOverride[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("wafClustersOverride" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateXForwardedForBehavior(formats strfmt.Registry) error {

	if swag.IsZero(m.XForwardedForBehavior) { // not required
		return nil
	}

	if m.XForwardedForBehavior != nil {
		if err := m.XForwardedForBehavior.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("xForwardedForBehavior")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CustconfConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustconfConfiguration) UnmarshalBinary(b []byte) error {
	var res CustconfConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

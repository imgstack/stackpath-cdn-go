// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CustconfConfiguration custconf configuration
//
// swagger:model custconfConfiguration
type CustconfConfiguration struct {

	// access logs
	AccessLogs *CustconfAccessLogs `json:"accessLogs,omitempty"`

	// access logs config
	AccessLogsConfig *CustconfAccessLogsConfig `json:"accessLogsConfig,omitempty"`

	// IP address restrictions allow you to configure your CDN container to grant or deny a specific IP addresses or range of IP addresses from accessing content cached in a directory in your CDN container.
	AuthACL []*CustconfAuthACL `json:"authACL,omitempty"`

	// Geographic restrictions allow you to restrict content to end users in specific locations. The IP address of incoming requests is checked against a current list of IP allocations to countries and to states within the US. If an end user's IP address is not found in the list, they are allowed access to the content by default. The feature has both an Include and an Exclude list which are used to target the allowed audience.
	AuthGeo []*CustconfAuthGeo `json:"authGeo,omitempty"`

	// auth Http basic
	AuthHTTPBasic *CustconfAuthHTTPBasic `json:"authHttpBasic,omitempty"`

	// auth referer
	AuthReferer *CustconfAuthReferer `json:"authReferer,omitempty"`

	// auth Url asymmetric sign tlu
	AuthURLAsymmetricSignTlu []*CustconfAuthURLAsymmetricSignTlu `json:"authUrlAsymmetricSignTlu,omitempty"`

	// URL Signing policies allow you to restrict access to your content by configuring a "shared secret" with StackPath. This "shared secret" is used to apply an MD5 hashing algorithm on the URL to validate the signature supplied on the request. Since the "shared secret" is only known by the publisher and StackPath, URL signatures cannot be generated by unauthorized users.
	AuthURLSign []*CustconfAuthURLSign `json:"authUrlSign,omitempty"`

	// auth Url sign ali cloud a
	AuthURLSignAliCloudA []*CustconfAuthURLSignAliCloudA `json:"authUrlSignAliCloudA,omitempty"`

	// auth Url sign ali cloud b
	AuthURLSignAliCloudB []*CustconfAuthURLSignAliCloudB `json:"authUrlSignAliCloudB,omitempty"`

	// auth Url sign ali cloud c
	AuthURLSignAliCloudC []*CustconfAuthURLSignAliCloudC `json:"authUrlSignAliCloudC,omitempty"`

	// auth Url sign hmac tlu
	AuthURLSignHmacTlu []*CustconfAuthURLSignHmacTlu `json:"authUrlSignHmacTlu,omitempty"`

	// auth Url sign iq
	AuthURLSignIq []*CustconfAuthURLSignIq `json:"authUrlSignIq,omitempty"`

	// aws signed origin pull v4
	AwsSignedOriginPullV4 []*CustconfAwsSignedOriginPullV4 `json:"awsSignedOriginPullV4,omitempty"`

	// aws signed s3 post v4
	AwsSignedS3PostV4 []*CustconfAwsSignedS3PostV4 `json:"awsSignedS3PostV4,omitempty"`

	// band width limit
	BandWidthLimit *CustconfBandWidthLimit `json:"bandWidthLimit,omitempty"`

	// band width rate limit units
	BandWidthRateLimitUnits *CustconfBandWidthRateLimitUnits `json:"bandWidthRateLimitUnits,omitempty"`

	// bandwidth rate limit
	BandwidthRateLimit *CustconfBandwidthRateLimit `json:"bandwidthRateLimit,omitempty"`

	// The browser caching policy allows you to control the browser caching behavior of your assets independently from the CDN cache. For example, this policy allows you to set lower or higher TTLs for the browser than those of the CDN cache.
	CacheControl []*CustconfCacheControl `json:"cacheControl,omitempty"`

	// cache key modification
	CacheKeyModification *CustconfCacheKeyModification `json:"cacheKeyModification,omitempty"`

	// client request modification
	ClientRequestModification []*CustconfClientRequestModification `json:"clientRequestModification,omitempty"`

	// client response modification
	ClientResponseModification []*CustconfClientResponseModification `json:"clientResponseModification,omitempty"`

	// compression
	Compression *CustconfCompression `json:"compression,omitempty"`

	// The content disposition by HTTP header match policy allows you to control the Content-Disposition delivered by the CDN using a pattern match against the value of any HTTP header present in the request. If you are using URL query string parameters to control the Content-Disposition header (using the Content Disposition by URL policy) then the Content-Disposition header generated by this policy will not be used on that specific request. A typical use case for this policy is to set a different Content-Disposition header based on the User-Agent in the request.
	ContentDispositionByHeader []*CustconfContentDispositionByHeader `json:"contentDispositionByHeader,omitempty"`

	// content disposition by URL
	ContentDispositionByURL *CustconfContentDispositionByURL `json:"contentDispositionByURL,omitempty"`

	// custom header
	CustomHeader *CustconfCustomHeader `json:"customHeader,omitempty"`

	// The custom mime type policy allows you to map file extensions to specific mime types for the CDN caching servers to use when delivering assets. The mime types you map using this policy may also be limited to specific response codes to address scenarios in which the mime type changes based on the response code.
	CustomMimeType []*CustconfCustomMimeType `json:"customMimeType,omitempty"`

	// customer
	Customer *CustconfCustomer `json:"customer,omitempty"`

	// Client response based on Rules.
	DynamicCacheRule []*CustconfDynamicCacheRule `json:"dynamicCacheRule,omitempty"`

	// The dynamic content caching policy allows you to specify a set of query string and/or HTTP header key/value pairs that should create a unique cache entry for a given URL. This policy is useful when your origin returns unique content for the same URL based on a set of query string parameters provided in the request.
	DynamicContent []*CustconfDynamicContent `json:"dynamicContent,omitempty"`

	// fail safe origin pull
	FailSafeOriginPull *CustconfFailSafeOriginPull `json:"failSafeOriginPull,omitempty"`

	// far ahead range proxy
	FarAheadRangeProxy *CustconfFarAheadRangeProxy `json:"farAheadRangeProxy,omitempty"`

	// file segmentation
	FileSegmentation *CustconfFileSegmentation `json:"fileSegmentation,omitempty"`

	// flv pseudo streaming
	FlvPseudoStreaming *CustconfFlvPseudoStreaming `json:"flvPseudoStreaming,omitempty"`

	// gzip origin pull
	GzipOriginPull *CustconfGzipOriginPull `json:"gzipOriginPull,omitempty"`

	// http2 support
	Http2Support *CustconfHttp2Support `json:"http2Support,omitempty"`

	// http methods
	HTTPMethods *CustconfHTTPMethods `json:"httpMethods,omitempty"`

	// origin
	Origin []*CdncustconfOrigin `json:"origin,omitempty"`

	// origin persistent connections
	OriginPersistentConnections *CustconfOriginPersistentConnections `json:"originPersistentConnections,omitempty"`

	// origin pull
	OriginPull *CustconfOriginPull `json:"originPull,omitempty"`

	// origin pull cache extension
	OriginPullCacheExtension *CustconfOriginPullCacheExtension `json:"originPullCacheExtension,omitempty"`

	// origin pull host
	OriginPullHost []*CustconfOriginPullHost `json:"originPullHost,omitempty"`

	// origin pull logs
	OriginPullLogs *CustconfOriginPullLogs `json:"originPullLogs,omitempty"`

	// origin pull logs config
	OriginPullLogsConfig *CustconfOriginPullLogsConfig `json:"originPullLogsConfig,omitempty"`

	// The CDN caching policy allows you to control how your origin's content is cached on the CDN.
	OriginPullPolicy []*CustconfOriginPullPolicy `json:"originPullPolicy,omitempty"`

	// origin pull protocol
	OriginPullProtocol *CustconfOriginPullProtocol `json:"originPullProtocol,omitempty"`

	// origin request modification
	OriginRequestModification []*CustconfOriginRequestModification `json:"originRequestModification,omitempty"`

	// origin response modification
	OriginResponseModification []*CustconfOriginResponseModification `json:"originResponseModification,omitempty"`

	// query str param
	QueryStrParam *CustconfQueryStrParam `json:"queryStrParam,omitempty"`

	// receipt logs config
	ReceiptLogsConfig *CustconfReceiptLogsConfig `json:"receiptLogsConfig,omitempty"`

	// redirect exceptions
	RedirectExceptions *CustconfRedirectExceptions `json:"redirectExceptions,omitempty"`

	// The response code redirection policy allows you to map cache response codes to an HTTP redirect response. When this policy is applied to a host, the caching servers will redirect clients to the URL specified in this policy instead of delivering the response code you mapped in the policy.
	RedirectMappings []*CustconfRedirectMappings `json:"redirectMappings,omitempty"`

	// response header
	ResponseHeader *CustconfResponseHeader `json:"responseHeader,omitempty"`

	// robots txt
	RobotsTxt []*CustconfRobotsTxt `json:"robotsTxt,omitempty"`

	// The static header injection policy allows you to insert headers into the CDN request and response processor.
	StaticHeader []*CustconfStaticHeader `json:"staticHeader,omitempty"`

	// time pseudo streaming
	TimePseudoStreaming *CustconfTimePseudoStreaming `json:"timePseudoStreaming,omitempty"`

	// A hostname policy allows you to specify an alternate domain name that you want to use to access content from your CDN container.
	VHost []*CustconfVHost `json:"vHost,omitempty"`

	// vary header field
	VaryHeaderField *CustconfVaryHeaderField `json:"varyHeaderField,omitempty"`
}

// Validate validates this custconf configuration
func (m *CustconfConfiguration) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAccessLogsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthACL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthGeo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthHTTPBasic(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthReferer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLAsymmetricSignTlu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSign(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAliCloudA(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAliCloudB(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignAliCloudC(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignHmacTlu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAuthURLSignIq(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsSignedOriginPullV4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAwsSignedS3PostV4(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBandWidthLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBandWidthRateLimitUnits(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBandwidthRateLimit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheControl(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCacheKeyModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientRequestModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClientResponseModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCompression(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentDispositionByHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContentDispositionByURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomMimeType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCustomer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicCacheRule(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDynamicContent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailSafeOriginPull(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFarAheadRangeProxy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileSegmentation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlvPseudoStreaming(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGzipOriginPull(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHttp2Support(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHTTPMethods(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOrigin(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPersistentConnections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPull(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullCacheExtension(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullLogs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullLogsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginPullProtocol(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginRequestModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOriginResponseModification(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateQueryStrParam(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReceiptLogsConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedirectExceptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRedirectMappings(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRobotsTxt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStaticHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimePseudoStreaming(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVaryHeaderField(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustconfConfiguration) validateAccessLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessLogs) { // not required
		return nil
	}

	if m.AccessLogs != nil {
		if err := m.AccessLogs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAccessLogsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessLogsConfig) { // not required
		return nil
	}

	if m.AccessLogsConfig != nil {
		if err := m.AccessLogsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthACL(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthACL) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthACL); i++ {
		if swag.IsZero(m.AuthACL[i]) { // not required
			continue
		}

		if m.AuthACL[i] != nil {
			if err := m.AuthACL[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authACL" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthGeo(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthGeo) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthGeo); i++ {
		if swag.IsZero(m.AuthGeo[i]) { // not required
			continue
		}

		if m.AuthGeo[i] != nil {
			if err := m.AuthGeo[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authGeo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthHTTPBasic(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthHTTPBasic) { // not required
		return nil
	}

	if m.AuthHTTPBasic != nil {
		if err := m.AuthHTTPBasic.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authHttpBasic")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthReferer(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthReferer) { // not required
		return nil
	}

	if m.AuthReferer != nil {
		if err := m.AuthReferer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authReferer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLAsymmetricSignTlu(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLAsymmetricSignTlu) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLAsymmetricSignTlu); i++ {
		if swag.IsZero(m.AuthURLAsymmetricSignTlu[i]) { // not required
			continue
		}

		if m.AuthURLAsymmetricSignTlu[i] != nil {
			if err := m.AuthURLAsymmetricSignTlu[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlAsymmetricSignTlu" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSign(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLSign) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSign); i++ {
		if swag.IsZero(m.AuthURLSign[i]) { // not required
			continue
		}

		if m.AuthURLSign[i] != nil {
			if err := m.AuthURLSign[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSign" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAliCloudA(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLSignAliCloudA) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAliCloudA); i++ {
		if swag.IsZero(m.AuthURLSignAliCloudA[i]) { // not required
			continue
		}

		if m.AuthURLSignAliCloudA[i] != nil {
			if err := m.AuthURLSignAliCloudA[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudA" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAliCloudB(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLSignAliCloudB) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAliCloudB); i++ {
		if swag.IsZero(m.AuthURLSignAliCloudB[i]) { // not required
			continue
		}

		if m.AuthURLSignAliCloudB[i] != nil {
			if err := m.AuthURLSignAliCloudB[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudB" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignAliCloudC(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLSignAliCloudC) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignAliCloudC); i++ {
		if swag.IsZero(m.AuthURLSignAliCloudC[i]) { // not required
			continue
		}

		if m.AuthURLSignAliCloudC[i] != nil {
			if err := m.AuthURLSignAliCloudC[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudC" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignHmacTlu(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLSignHmacTlu) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignHmacTlu); i++ {
		if swag.IsZero(m.AuthURLSignHmacTlu[i]) { // not required
			continue
		}

		if m.AuthURLSignHmacTlu[i] != nil {
			if err := m.AuthURLSignHmacTlu[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignHmacTlu" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAuthURLSignIq(formats strfmt.Registry) error {
	if swag.IsZero(m.AuthURLSignIq) { // not required
		return nil
	}

	for i := 0; i < len(m.AuthURLSignIq); i++ {
		if swag.IsZero(m.AuthURLSignIq[i]) { // not required
			continue
		}

		if m.AuthURLSignIq[i] != nil {
			if err := m.AuthURLSignIq[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignIq" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAwsSignedOriginPullV4(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsSignedOriginPullV4) { // not required
		return nil
	}

	for i := 0; i < len(m.AwsSignedOriginPullV4); i++ {
		if swag.IsZero(m.AwsSignedOriginPullV4[i]) { // not required
			continue
		}

		if m.AwsSignedOriginPullV4[i] != nil {
			if err := m.AwsSignedOriginPullV4[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("awsSignedOriginPullV4" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateAwsSignedS3PostV4(formats strfmt.Registry) error {
	if swag.IsZero(m.AwsSignedS3PostV4) { // not required
		return nil
	}

	for i := 0; i < len(m.AwsSignedS3PostV4); i++ {
		if swag.IsZero(m.AwsSignedS3PostV4[i]) { // not required
			continue
		}

		if m.AwsSignedS3PostV4[i] != nil {
			if err := m.AwsSignedS3PostV4[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("awsSignedS3PostV4" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateBandWidthLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.BandWidthLimit) { // not required
		return nil
	}

	if m.BandWidthLimit != nil {
		if err := m.BandWidthLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandWidthLimit")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateBandWidthRateLimitUnits(formats strfmt.Registry) error {
	if swag.IsZero(m.BandWidthRateLimitUnits) { // not required
		return nil
	}

	if m.BandWidthRateLimitUnits != nil {
		if err := m.BandWidthRateLimitUnits.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandWidthRateLimitUnits")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateBandwidthRateLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.BandwidthRateLimit) { // not required
		return nil
	}

	if m.BandwidthRateLimit != nil {
		if err := m.BandwidthRateLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidthRateLimit")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCacheControl(formats strfmt.Registry) error {
	if swag.IsZero(m.CacheControl) { // not required
		return nil
	}

	for i := 0; i < len(m.CacheControl); i++ {
		if swag.IsZero(m.CacheControl[i]) { // not required
			continue
		}

		if m.CacheControl[i] != nil {
			if err := m.CacheControl[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cacheControl" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateCacheKeyModification(formats strfmt.Registry) error {
	if swag.IsZero(m.CacheKeyModification) { // not required
		return nil
	}

	if m.CacheKeyModification != nil {
		if err := m.CacheKeyModification.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cacheKeyModification")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateClientRequestModification(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientRequestModification) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientRequestModification); i++ {
		if swag.IsZero(m.ClientRequestModification[i]) { // not required
			continue
		}

		if m.ClientRequestModification[i] != nil {
			if err := m.ClientRequestModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientRequestModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateClientResponseModification(formats strfmt.Registry) error {
	if swag.IsZero(m.ClientResponseModification) { // not required
		return nil
	}

	for i := 0; i < len(m.ClientResponseModification); i++ {
		if swag.IsZero(m.ClientResponseModification[i]) { // not required
			continue
		}

		if m.ClientResponseModification[i] != nil {
			if err := m.ClientResponseModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientResponseModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateCompression(formats strfmt.Registry) error {
	if swag.IsZero(m.Compression) { // not required
		return nil
	}

	if m.Compression != nil {
		if err := m.Compression.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("compression")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateContentDispositionByHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentDispositionByHeader) { // not required
		return nil
	}

	for i := 0; i < len(m.ContentDispositionByHeader); i++ {
		if swag.IsZero(m.ContentDispositionByHeader[i]) { // not required
			continue
		}

		if m.ContentDispositionByHeader[i] != nil {
			if err := m.ContentDispositionByHeader[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentDispositionByHeader" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateContentDispositionByURL(formats strfmt.Registry) error {
	if swag.IsZero(m.ContentDispositionByURL) { // not required
		return nil
	}

	if m.ContentDispositionByURL != nil {
		if err := m.ContentDispositionByURL.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contentDispositionByURL")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCustomHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomHeader) { // not required
		return nil
	}

	if m.CustomHeader != nil {
		if err := m.CustomHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customHeader")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateCustomMimeType(formats strfmt.Registry) error {
	if swag.IsZero(m.CustomMimeType) { // not required
		return nil
	}

	for i := 0; i < len(m.CustomMimeType); i++ {
		if swag.IsZero(m.CustomMimeType[i]) { // not required
			continue
		}

		if m.CustomMimeType[i] != nil {
			if err := m.CustomMimeType[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customMimeType" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateCustomer(formats strfmt.Registry) error {
	if swag.IsZero(m.Customer) { // not required
		return nil
	}

	if m.Customer != nil {
		if err := m.Customer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateDynamicCacheRule(formats strfmt.Registry) error {
	if swag.IsZero(m.DynamicCacheRule) { // not required
		return nil
	}

	for i := 0; i < len(m.DynamicCacheRule); i++ {
		if swag.IsZero(m.DynamicCacheRule[i]) { // not required
			continue
		}

		if m.DynamicCacheRule[i] != nil {
			if err := m.DynamicCacheRule[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicCacheRule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateDynamicContent(formats strfmt.Registry) error {
	if swag.IsZero(m.DynamicContent) { // not required
		return nil
	}

	for i := 0; i < len(m.DynamicContent); i++ {
		if swag.IsZero(m.DynamicContent[i]) { // not required
			continue
		}

		if m.DynamicContent[i] != nil {
			if err := m.DynamicContent[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicContent" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateFailSafeOriginPull(formats strfmt.Registry) error {
	if swag.IsZero(m.FailSafeOriginPull) { // not required
		return nil
	}

	if m.FailSafeOriginPull != nil {
		if err := m.FailSafeOriginPull.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failSafeOriginPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFarAheadRangeProxy(formats strfmt.Registry) error {
	if swag.IsZero(m.FarAheadRangeProxy) { // not required
		return nil
	}

	if m.FarAheadRangeProxy != nil {
		if err := m.FarAheadRangeProxy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("farAheadRangeProxy")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFileSegmentation(formats strfmt.Registry) error {
	if swag.IsZero(m.FileSegmentation) { // not required
		return nil
	}

	if m.FileSegmentation != nil {
		if err := m.FileSegmentation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileSegmentation")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateFlvPseudoStreaming(formats strfmt.Registry) error {
	if swag.IsZero(m.FlvPseudoStreaming) { // not required
		return nil
	}

	if m.FlvPseudoStreaming != nil {
		if err := m.FlvPseudoStreaming.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flvPseudoStreaming")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateGzipOriginPull(formats strfmt.Registry) error {
	if swag.IsZero(m.GzipOriginPull) { // not required
		return nil
	}

	if m.GzipOriginPull != nil {
		if err := m.GzipOriginPull.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gzipOriginPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateHttp2Support(formats strfmt.Registry) error {
	if swag.IsZero(m.Http2Support) { // not required
		return nil
	}

	if m.Http2Support != nil {
		if err := m.Http2Support.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("http2Support")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateHTTPMethods(formats strfmt.Registry) error {
	if swag.IsZero(m.HTTPMethods) { // not required
		return nil
	}

	if m.HTTPMethods != nil {
		if err := m.HTTPMethods.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("httpMethods")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOrigin(formats strfmt.Registry) error {
	if swag.IsZero(m.Origin) { // not required
		return nil
	}

	for i := 0; i < len(m.Origin); i++ {
		if swag.IsZero(m.Origin[i]) { // not required
			continue
		}

		if m.Origin[i] != nil {
			if err := m.Origin[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("origin" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPersistentConnections(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPersistentConnections) { // not required
		return nil
	}

	if m.OriginPersistentConnections != nil {
		if err := m.OriginPersistentConnections.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPersistentConnections")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPull(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPull) { // not required
		return nil
	}

	if m.OriginPull != nil {
		if err := m.OriginPull.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullCacheExtension(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPullCacheExtension) { // not required
		return nil
	}

	if m.OriginPullCacheExtension != nil {
		if err := m.OriginPullCacheExtension.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullCacheExtension")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullHost(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPullHost) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginPullHost); i++ {
		if swag.IsZero(m.OriginPullHost[i]) { // not required
			continue
		}

		if m.OriginPullHost[i] != nil {
			if err := m.OriginPullHost[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullHost" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullLogs(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPullLogs) { // not required
		return nil
	}

	if m.OriginPullLogs != nil {
		if err := m.OriginPullLogs.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullLogsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPullLogsConfig) { // not required
		return nil
	}

	if m.OriginPullLogsConfig != nil {
		if err := m.OriginPullLogsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPullPolicy) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginPullPolicy); i++ {
		if swag.IsZero(m.OriginPullPolicy[i]) { // not required
			continue
		}

		if m.OriginPullPolicy[i] != nil {
			if err := m.OriginPullPolicy[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullPolicy" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginPullProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginPullProtocol) { // not required
		return nil
	}

	if m.OriginPullProtocol != nil {
		if err := m.OriginPullProtocol.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullProtocol")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateOriginRequestModification(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginRequestModification) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginRequestModification); i++ {
		if swag.IsZero(m.OriginRequestModification[i]) { // not required
			continue
		}

		if m.OriginRequestModification[i] != nil {
			if err := m.OriginRequestModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originRequestModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateOriginResponseModification(formats strfmt.Registry) error {
	if swag.IsZero(m.OriginResponseModification) { // not required
		return nil
	}

	for i := 0; i < len(m.OriginResponseModification); i++ {
		if swag.IsZero(m.OriginResponseModification[i]) { // not required
			continue
		}

		if m.OriginResponseModification[i] != nil {
			if err := m.OriginResponseModification[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originResponseModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateQueryStrParam(formats strfmt.Registry) error {
	if swag.IsZero(m.QueryStrParam) { // not required
		return nil
	}

	if m.QueryStrParam != nil {
		if err := m.QueryStrParam.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryStrParam")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateReceiptLogsConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.ReceiptLogsConfig) { // not required
		return nil
	}

	if m.ReceiptLogsConfig != nil {
		if err := m.ReceiptLogsConfig.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("receiptLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRedirectExceptions(formats strfmt.Registry) error {
	if swag.IsZero(m.RedirectExceptions) { // not required
		return nil
	}

	if m.RedirectExceptions != nil {
		if err := m.RedirectExceptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("redirectExceptions")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRedirectMappings(formats strfmt.Registry) error {
	if swag.IsZero(m.RedirectMappings) { // not required
		return nil
	}

	for i := 0; i < len(m.RedirectMappings); i++ {
		if swag.IsZero(m.RedirectMappings[i]) { // not required
			continue
		}

		if m.RedirectMappings[i] != nil {
			if err := m.RedirectMappings[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("redirectMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateResponseHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.ResponseHeader) { // not required
		return nil
	}

	if m.ResponseHeader != nil {
		if err := m.ResponseHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("responseHeader")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateRobotsTxt(formats strfmt.Registry) error {
	if swag.IsZero(m.RobotsTxt) { // not required
		return nil
	}

	for i := 0; i < len(m.RobotsTxt); i++ {
		if swag.IsZero(m.RobotsTxt[i]) { // not required
			continue
		}

		if m.RobotsTxt[i] != nil {
			if err := m.RobotsTxt[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("robotsTxt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateStaticHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.StaticHeader) { // not required
		return nil
	}

	for i := 0; i < len(m.StaticHeader); i++ {
		if swag.IsZero(m.StaticHeader[i]) { // not required
			continue
		}

		if m.StaticHeader[i] != nil {
			if err := m.StaticHeader[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("staticHeader" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateTimePseudoStreaming(formats strfmt.Registry) error {
	if swag.IsZero(m.TimePseudoStreaming) { // not required
		return nil
	}

	if m.TimePseudoStreaming != nil {
		if err := m.TimePseudoStreaming.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timePseudoStreaming")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) validateVHost(formats strfmt.Registry) error {
	if swag.IsZero(m.VHost) { // not required
		return nil
	}

	for i := 0; i < len(m.VHost); i++ {
		if swag.IsZero(m.VHost[i]) { // not required
			continue
		}

		if m.VHost[i] != nil {
			if err := m.VHost[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vHost" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) validateVaryHeaderField(formats strfmt.Registry) error {
	if swag.IsZero(m.VaryHeaderField) { // not required
		return nil
	}

	if m.VaryHeaderField != nil {
		if err := m.VaryHeaderField.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("varyHeaderField")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this custconf configuration based on the context it is used
func (m *CustconfConfiguration) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccessLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAccessLogsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthACL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthGeo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthHTTPBasic(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthReferer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLAsymmetricSignTlu(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLSign(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLSignAliCloudA(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLSignAliCloudB(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLSignAliCloudC(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLSignHmacTlu(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAuthURLSignIq(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAwsSignedOriginPullV4(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAwsSignedS3PostV4(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBandWidthLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBandWidthRateLimitUnits(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBandwidthRateLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCacheControl(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCacheKeyModification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClientRequestModification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateClientResponseModification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCompression(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentDispositionByHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContentDispositionByURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomMimeType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCustomer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDynamicCacheRule(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDynamicContent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFailSafeOriginPull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFarAheadRangeProxy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFileSegmentation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFlvPseudoStreaming(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGzipOriginPull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHttp2Support(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHTTPMethods(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOrigin(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPersistentConnections(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPull(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPullCacheExtension(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPullHost(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPullLogs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPullLogsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPullPolicy(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginPullProtocol(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginRequestModification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOriginResponseModification(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateQueryStrParam(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateReceiptLogsConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRedirectExceptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRedirectMappings(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateResponseHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRobotsTxt(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStaticHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTimePseudoStreaming(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVHost(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVaryHeaderField(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustconfConfiguration) contextValidateAccessLogs(ctx context.Context, formats strfmt.Registry) error {

	if m.AccessLogs != nil {
		if err := m.AccessLogs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAccessLogsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.AccessLogsConfig != nil {
		if err := m.AccessLogsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("accessLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthACL(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthACL); i++ {

		if m.AuthACL[i] != nil {
			if err := m.AuthACL[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authACL" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthGeo(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthGeo); i++ {

		if m.AuthGeo[i] != nil {
			if err := m.AuthGeo[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authGeo" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthHTTPBasic(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthHTTPBasic != nil {
		if err := m.AuthHTTPBasic.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authHttpBasic")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthReferer(ctx context.Context, formats strfmt.Registry) error {

	if m.AuthReferer != nil {
		if err := m.AuthReferer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("authReferer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLAsymmetricSignTlu(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLAsymmetricSignTlu); i++ {

		if m.AuthURLAsymmetricSignTlu[i] != nil {
			if err := m.AuthURLAsymmetricSignTlu[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlAsymmetricSignTlu" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLSign(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLSign); i++ {

		if m.AuthURLSign[i] != nil {
			if err := m.AuthURLSign[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSign" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLSignAliCloudA(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLSignAliCloudA); i++ {

		if m.AuthURLSignAliCloudA[i] != nil {
			if err := m.AuthURLSignAliCloudA[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudA" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLSignAliCloudB(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLSignAliCloudB); i++ {

		if m.AuthURLSignAliCloudB[i] != nil {
			if err := m.AuthURLSignAliCloudB[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudB" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLSignAliCloudC(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLSignAliCloudC); i++ {

		if m.AuthURLSignAliCloudC[i] != nil {
			if err := m.AuthURLSignAliCloudC[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignAliCloudC" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLSignHmacTlu(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLSignHmacTlu); i++ {

		if m.AuthURLSignHmacTlu[i] != nil {
			if err := m.AuthURLSignHmacTlu[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignHmacTlu" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAuthURLSignIq(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AuthURLSignIq); i++ {

		if m.AuthURLSignIq[i] != nil {
			if err := m.AuthURLSignIq[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("authUrlSignIq" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAwsSignedOriginPullV4(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AwsSignedOriginPullV4); i++ {

		if m.AwsSignedOriginPullV4[i] != nil {
			if err := m.AwsSignedOriginPullV4[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("awsSignedOriginPullV4" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateAwsSignedS3PostV4(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.AwsSignedS3PostV4); i++ {

		if m.AwsSignedS3PostV4[i] != nil {
			if err := m.AwsSignedS3PostV4[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("awsSignedS3PostV4" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateBandWidthLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.BandWidthLimit != nil {
		if err := m.BandWidthLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandWidthLimit")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateBandWidthRateLimitUnits(ctx context.Context, formats strfmt.Registry) error {

	if m.BandWidthRateLimitUnits != nil {
		if err := m.BandWidthRateLimitUnits.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandWidthRateLimitUnits")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateBandwidthRateLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.BandwidthRateLimit != nil {
		if err := m.BandwidthRateLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("bandwidthRateLimit")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateCacheControl(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CacheControl); i++ {

		if m.CacheControl[i] != nil {
			if err := m.CacheControl[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cacheControl" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateCacheKeyModification(ctx context.Context, formats strfmt.Registry) error {

	if m.CacheKeyModification != nil {
		if err := m.CacheKeyModification.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cacheKeyModification")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateClientRequestModification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClientRequestModification); i++ {

		if m.ClientRequestModification[i] != nil {
			if err := m.ClientRequestModification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientRequestModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateClientResponseModification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ClientResponseModification); i++ {

		if m.ClientResponseModification[i] != nil {
			if err := m.ClientResponseModification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("clientResponseModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateCompression(ctx context.Context, formats strfmt.Registry) error {

	if m.Compression != nil {
		if err := m.Compression.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("compression")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateContentDispositionByHeader(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ContentDispositionByHeader); i++ {

		if m.ContentDispositionByHeader[i] != nil {
			if err := m.ContentDispositionByHeader[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("contentDispositionByHeader" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateContentDispositionByURL(ctx context.Context, formats strfmt.Registry) error {

	if m.ContentDispositionByURL != nil {
		if err := m.ContentDispositionByURL.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("contentDispositionByURL")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateCustomHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.CustomHeader != nil {
		if err := m.CustomHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customHeader")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateCustomMimeType(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CustomMimeType); i++ {

		if m.CustomMimeType[i] != nil {
			if err := m.CustomMimeType[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("customMimeType" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateCustomer(ctx context.Context, formats strfmt.Registry) error {

	if m.Customer != nil {
		if err := m.Customer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("customer")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateDynamicCacheRule(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DynamicCacheRule); i++ {

		if m.DynamicCacheRule[i] != nil {
			if err := m.DynamicCacheRule[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicCacheRule" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateDynamicContent(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DynamicContent); i++ {

		if m.DynamicContent[i] != nil {
			if err := m.DynamicContent[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dynamicContent" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateFailSafeOriginPull(ctx context.Context, formats strfmt.Registry) error {

	if m.FailSafeOriginPull != nil {
		if err := m.FailSafeOriginPull.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("failSafeOriginPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateFarAheadRangeProxy(ctx context.Context, formats strfmt.Registry) error {

	if m.FarAheadRangeProxy != nil {
		if err := m.FarAheadRangeProxy.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("farAheadRangeProxy")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateFileSegmentation(ctx context.Context, formats strfmt.Registry) error {

	if m.FileSegmentation != nil {
		if err := m.FileSegmentation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("fileSegmentation")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateFlvPseudoStreaming(ctx context.Context, formats strfmt.Registry) error {

	if m.FlvPseudoStreaming != nil {
		if err := m.FlvPseudoStreaming.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("flvPseudoStreaming")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateGzipOriginPull(ctx context.Context, formats strfmt.Registry) error {

	if m.GzipOriginPull != nil {
		if err := m.GzipOriginPull.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gzipOriginPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateHttp2Support(ctx context.Context, formats strfmt.Registry) error {

	if m.Http2Support != nil {
		if err := m.Http2Support.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("http2Support")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateHTTPMethods(ctx context.Context, formats strfmt.Registry) error {

	if m.HTTPMethods != nil {
		if err := m.HTTPMethods.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("httpMethods")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOrigin(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Origin); i++ {

		if m.Origin[i] != nil {
			if err := m.Origin[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("origin" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPersistentConnections(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginPersistentConnections != nil {
		if err := m.OriginPersistentConnections.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPersistentConnections")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPull(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginPull != nil {
		if err := m.OriginPull.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPull")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPullCacheExtension(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginPullCacheExtension != nil {
		if err := m.OriginPullCacheExtension.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullCacheExtension")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPullHost(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OriginPullHost); i++ {

		if m.OriginPullHost[i] != nil {
			if err := m.OriginPullHost[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullHost" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPullLogs(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginPullLogs != nil {
		if err := m.OriginPullLogs.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullLogs")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPullLogsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginPullLogsConfig != nil {
		if err := m.OriginPullLogsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPullPolicy(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OriginPullPolicy); i++ {

		if m.OriginPullPolicy[i] != nil {
			if err := m.OriginPullPolicy[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originPullPolicy" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginPullProtocol(ctx context.Context, formats strfmt.Registry) error {

	if m.OriginPullProtocol != nil {
		if err := m.OriginPullProtocol.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("originPullProtocol")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginRequestModification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OriginRequestModification); i++ {

		if m.OriginRequestModification[i] != nil {
			if err := m.OriginRequestModification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originRequestModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateOriginResponseModification(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.OriginResponseModification); i++ {

		if m.OriginResponseModification[i] != nil {
			if err := m.OriginResponseModification[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("originResponseModification" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateQueryStrParam(ctx context.Context, formats strfmt.Registry) error {

	if m.QueryStrParam != nil {
		if err := m.QueryStrParam.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("queryStrParam")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateReceiptLogsConfig(ctx context.Context, formats strfmt.Registry) error {

	if m.ReceiptLogsConfig != nil {
		if err := m.ReceiptLogsConfig.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("receiptLogsConfig")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateRedirectExceptions(ctx context.Context, formats strfmt.Registry) error {

	if m.RedirectExceptions != nil {
		if err := m.RedirectExceptions.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("redirectExceptions")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateRedirectMappings(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RedirectMappings); i++ {

		if m.RedirectMappings[i] != nil {
			if err := m.RedirectMappings[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("redirectMappings" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateResponseHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.ResponseHeader != nil {
		if err := m.ResponseHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("responseHeader")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateRobotsTxt(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.RobotsTxt); i++ {

		if m.RobotsTxt[i] != nil {
			if err := m.RobotsTxt[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("robotsTxt" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateStaticHeader(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.StaticHeader); i++ {

		if m.StaticHeader[i] != nil {
			if err := m.StaticHeader[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("staticHeader" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateTimePseudoStreaming(ctx context.Context, formats strfmt.Registry) error {

	if m.TimePseudoStreaming != nil {
		if err := m.TimePseudoStreaming.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timePseudoStreaming")
			}
			return err
		}
	}

	return nil
}

func (m *CustconfConfiguration) contextValidateVHost(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VHost); i++ {

		if m.VHost[i] != nil {
			if err := m.VHost[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vHost" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CustconfConfiguration) contextValidateVaryHeaderField(ctx context.Context, formats strfmt.Registry) error {

	if m.VaryHeaderField != nil {
		if err := m.VaryHeaderField.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("varyHeaderField")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CustconfConfiguration) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustconfConfiguration) UnmarshalBinary(b []byte) error {
	var res CustconfConfiguration
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

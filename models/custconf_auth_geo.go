// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CustconfAuthGeo Geographic restrictions allow you to restrict content to end users in specific locations. The IP address of incoming requests is checked against a current list of IP allocations to countries and to states within the US. If an end user's IP address is not found in the list, they are allowed access to the content by default. The feature has both an Include and an Exclude list which are used to target the allowed audience.
//
// swagger:model custconfAuthGeo
type CustconfAuthGeo struct {

	// code
	Code *AuthGeoCodeEnumWrapperValue `json:"code,omitempty"`

	// enabled
	Enabled bool `json:"enabled"`

	// This is used by the API to perform conflict checking
	ID string `json:"id,omitempty"`

	// String of values delimited by a ',' character. These are the region codes you are targeting for this policy. The values that can be supplied within this field are those that are supported by the MaxMindÂ® GeoIP database.
	Values string `json:"values,omitempty"`
}

// Validate validates this custconf auth geo
func (m *CustconfAuthGeo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustconfAuthGeo) validateCode(formats strfmt.Registry) error {
	if swag.IsZero(m.Code) { // not required
		return nil
	}

	if m.Code != nil {
		if err := m.Code.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("code")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this custconf auth geo based on the context it is used
func (m *CustconfAuthGeo) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CustconfAuthGeo) contextValidateCode(ctx context.Context, formats strfmt.Registry) error {

	if m.Code != nil {
		if err := m.Code.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("code")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CustconfAuthGeo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CustconfAuthGeo) UnmarshalBinary(b []byte) error {
	var res CustconfAuthGeo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
